int kvm_get_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata){
 u64 data;

 switch (msr){
 case MSR_IA32_PLATFORM_ID:
 case MSR_IA32_EBL_CR_POWERON:
 case MSR_IA32_DEBUGCTLMSR:
 case MSR_IA32_LASTBRANCHFROMIP:
 case MSR_IA32_LASTBRANCHTOIP:
 case MSR_IA32_LASTINTFROMIP:
 case MSR_IA32_LASTINTTOIP:
 case MSR_K8_SYSCFG:
 case MSR_K7_HWCR:
 case MSR_VM_HSAVE_PA:
 case MSR_K7_EVNTSEL0:
 case MSR_K7_PERFCTR0:
 case MSR_K8_INT_PENDING_MSG:
 case MSR_AMD64_NB_CFG:
 case MSR_FAM10H_MMIO_CONF_BASE:
 case MSR_AMD64_BU_CFG2:
  data = 0;
  break;
 case MSR_P6_PERFCTR0:
 case MSR_P6_PERFCTR1:
 case MSR_P6_EVNTSEL0:
 case MSR_P6_EVNTSEL1:
  if (kvm_pmu_msr(vcpu, msr))
   return kvm_pmu_get_msr(vcpu, msr, pdata);
  data = 0;
  break;
 case MSR_IA32_UCODE_REV:
  data = 0x100000000ULL;
  break;
 case MSR_MTRRcap:
  data = 0x500 | KVM_NR_VAR_MTRR;
  break;
 case 0x200 ... 0x2ff:
  return get_msr_mtrr(vcpu, msr, pdata);
 case 0xcd:
  data = 3;
  break;
# 2401 "originals/02a.c"
 case MSR_EBC_FREQUENCY_ID:
  data = 1 << 24;
  break;
 case MSR_IA32_APICBASE:
  data = kvm_get_apic_base(vcpu);
  break;
 case APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:
  return kvm_x2apic_msr_read(vcpu, msr, pdata);
  break;
 case MSR_IA32_TSCDEADLINE:
  data = kvm_get_lapic_tscdeadline_msr(vcpu);
  break;
 case MSR_IA32_TSC_ADJUST:
  data = (u64)vcpu->arch.ia32_tsc_adjust_msr;
  break;
 case MSR_IA32_MISC_ENABLE:
  data = vcpu->arch.ia32_misc_enable_msr;
  break;
 case MSR_IA32_PERF_STATUS:

  data = 1000ULL;

  data |= (((uint64_t)4ULL) << 40);
  break;
 case MSR_EFER:
  data = vcpu->arch.efer;
  break;
 case MSR_KVM_WALL_CLOCK:
 case MSR_KVM_WALL_CLOCK_NEW:
  data = vcpu->kvm->arch.wall_clock;
  break;
 case MSR_KVM_SYSTEM_TIME:
 case MSR_KVM_SYSTEM_TIME_NEW:
  data = vcpu->arch.time;
  break;
 case MSR_KVM_ASYNC_PF_EN:
  data = vcpu->arch.apf.msr_val;
  break;
 case MSR_KVM_STEAL_TIME:
  data = vcpu->arch.st.msr_val;
  break;
 case MSR_KVM_PV_EOI_EN:
  data = vcpu->arch.pv_eoi.msr_val;
  break;
 case MSR_IA32_P5_MC_ADDR:
 case MSR_IA32_P5_MC_TYPE:
 case MSR_IA32_MCG_CAP:
 case MSR_IA32_MCG_CTL:
 case MSR_IA32_MCG_STATUS:
 case MSR_IA32_MC0_CTL ... MSR_IA32_MC0_CTL + 4 * KVM_MAX_MCE_BANKS - 1:
  return get_msr_mce(vcpu, msr, pdata);
 case MSR_K7_CLK_CTL:
# 2462 "originals/02a.c"
  data = 0x20000000;
  break;
 case HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:
  if (kvm_hv_msr_partition_wide(msr)){
   int r;
   mutex_lock(&vcpu->kvm->lock);
   r = get_msr_hyperv_pw(vcpu, msr, pdata);
   mutex_unlock(&vcpu->kvm->lock);
   return r;
  } else
   return get_msr_hyperv(vcpu, msr, pdata);
  break;
 case MSR_IA32_BBL_CR_CTL3:
# 2485 "originals/02a.c"
  data = 0xbe702111;
  break;
 case MSR_AMD64_OSVW_ID_LENGTH:
  if (!guest_cpuid_has_osvw(vcpu))
   return 1;
  data = vcpu->arch.osvw.length;
  break;
 case MSR_AMD64_OSVW_STATUS:
  if (!guest_cpuid_has_osvw(vcpu))
   return 1;
  data = vcpu->arch.osvw.status;
  break;
 default:
  if (kvm_pmu_msr(vcpu, msr))
   return kvm_pmu_get_msr(vcpu, msr, pdata);
  if (!ignore_msrs){
   vcpu_unimpl(vcpu, "unhandled rdmsr: 0x%x\n", msr);
   return 1;
  } else{
   vcpu_unimpl(vcpu, "ignored rdmsr: 0x%x\n", msr);
   data = 0;
  }
  break;
 }
 *pdata = data;
 return 0;
}
