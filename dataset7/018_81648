void CLASS write_ppm_tiff(){
  struct tiff_hdr th;
  uchar *ppm;
  ushort *ppm2;
  int c, row, col, soff, rstep, cstep;
  int perc, val, total, white=0x2000;

  perc = width * height * 0.01;
  if (fuji_width) perc /= 2;
  if (!((highlight & ~2) || no_auto_bright))
    for (white=c=0; c < colors; c++){
      for (val=0x2000, total=0; --val > 32; )
 if ((total += histogram[c][val]) > perc) break;
      if (white < val) white = val;
    }
  gamma_curve (gamm[0], gamm[1], 2, (white << 3)/bright);
  iheight = height;
  iwidth = width;
  if (flip & 4) SWAP(height,width);
  ppm = (uchar *) calloc (width, colors*output_bps/8);
  ppm2 = (ushort *) ppm;
  merror (ppm, "write_ppm_tiff()");
  if (output_tiff){
    tiff_head (&th, 1);
    fwrite (&th, sizeof th, 1, ofp);
    if (oprof)
      fwrite (oprof, ntohl(oprof[0]), 1, ofp);
  } else if (colors > 3)
    fprintf (ofp,
      "P7\nWIDTH %d\nHEIGHT %d\nDEPTH %d\nMAXVAL %d\nTUPLTYPE %s\nENDHDR\n",
 width, height, colors, (1 << output_bps)-1, cdesc);
  else
    fprintf (ofp, "P%d\n%d %d\n%d\n",
 colors/2+5, width, height, (1 << output_bps)-1);
  soff = flip_index (0, 0);
  cstep = flip_index (0, 1) - soff;
  rstep = flip_index (1, 0) - flip_index (0, width);
  for (row=0; row < height; row++, soff += rstep){
    for (col=0; col < width; col++, soff += cstep)
      if (output_bps == 8)
    FORCC ppm [col*colors+c] = curve[image[soff][c]] >> 8;
      else FORCC ppm2[col*colors+c] = curve[image[soff][c]];
    if (output_bps == 16 && !output_tiff && htons(0x55aa) != 0x55aa)
      swab ((const char *)ppm2, (char *)ppm2, width*colors*2);
    fwrite (ppm, colors*output_bps/8, width, ofp);
  }
  free (ppm);
}
