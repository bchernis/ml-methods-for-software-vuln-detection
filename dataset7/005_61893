mcopy(struct magic_set *ms, union VALUETYPE *p, int type, int indir,
    const unsigned char *s, uint32_t offset, size_t nbytes, struct magic *m){




 if (indir == 0){
  switch (type){
  case FILE_SEARCH:
   ms->search.s = RCAST(const char *, s) + offset;
   ms->search.s_len = nbytes - offset;
   ms->search.offset = offset;
   return 0;

  case FILE_REGEX:{
   const char *b;
   const char *c;
   const char *last;
   const char *buf;
   const char *end;
   size_t lines, linecnt, bytecnt;

   if (s == NULL){
    ms->search.s_len = 0;
    ms->search.s = NULL;
    return 0;
   }

   if (m->str_flags & REGEX_LINE_COUNT){
    linecnt = m->str_range;
    bytecnt = linecnt * 80;
   } else{
    linecnt = 0;
    bytecnt = m->str_range;
   }

   if (bytecnt == 0)
    bytecnt = 8192;
   if (bytecnt > nbytes)
    bytecnt = nbytes;

   buf = RCAST(const char *, s) + offset;
   end = last = RCAST(const char *, s) + bytecnt;

   for (lines = linecnt, b = buf; lines && b < end &&
        ((b = CAST(const char *,
     memchr(c = b, '\n', CAST(size_t, (end - b)))))
        || (b = CAST(const char *,
     memchr(c, '\r', CAST(size_t, (end - c))))));
        lines--, b++){
    last = b;
    if (b[0] == '\r' && b[1] == '\n')
     b++;
   }
   if (lines)
    last = RCAST(const char *, s) + bytecnt;

   ms->search.s = buf;
   ms->search.s_len = last - buf;
   ms->search.offset = offset;
   ms->search.rm_len = 0;
   return 0;
  }
  case FILE_BESTRING16:
  case FILE_LESTRING16:{
   const unsigned char *src = s + offset;
   const unsigned char *esrc = s + nbytes;
   char *dst = p->s;
   char *edst = &p->s[sizeof(p->s) - 1];

   if (type == FILE_BESTRING16)
    src++;


   if (offset >= nbytes)
    break;
   for ( ; src < esrc; src += 2, dst++){
    if (dst < edst)
     *dst = *src;
    else
     break;
    if (*dst == '\0'){
     if (type == FILE_BESTRING16 ?
         *(src - 1) != '\0' :
         *(src + 1) != '\0')
      *dst = ' ';
    }
   }
   *edst = '\0';
   return 0;
  }
  case FILE_STRING:
  case FILE_PSTRING:
  default:
   break;
  }
 }

 if (offset >= nbytes){
  (void)memset(p, '\0', sizeof(*p));
  return 0;
 }
 if (nbytes - offset < sizeof(*p))
  nbytes = nbytes - offset;
 else
  nbytes = sizeof(*p);

 (void)memcpy(p, s + offset, nbytes);





 if (nbytes < sizeof(*p))
  (void)memset(((char *)(void *)p) + nbytes, '\0',
      sizeof(*p) - nbytes);
 return 0;
}
