int rxe_mem_copy(struct rxe_mem *mem, u64 iova, void *addr, int length,
   enum copy_direction dir, u32 *crcp){
 int err;
 int bytes;
 u8 *va;
 struct rxe_map **map;
 struct rxe_phys_buf *buf;
 int m;
 int i;
 size_t offset;
 u32 crc = crcp ? (*crcp) : 0;

 if (length == 0)
  return 0;

 if (mem->type == RXE_MEM_TYPE_DMA){
  u8 *src, *dest;

  src = (dir == to_mem_obj) ?
   addr : ((void *)(uintptr_t)iova);

  dest = (dir == to_mem_obj) ?
   ((void *)(uintptr_t)iova) : addr;

  if (crcp)
   *crcp = crc32_le(*crcp, src, length);

  memcpy(dest, src, length);

  return 0;
 }

 WARN_ON(!mem->map);

 err = mem_check_range(mem, iova, length);
 if (err){
  err = -EFAULT;
  goto err1;
 }

 lookup_iova(mem, iova, &m, &i, &offset);

 map = mem->map + m;
 buf = map[0]->buf + i;

 while (length > 0){
  u8 *src, *dest;

  va = (u8 *)(uintptr_t)buf->addr + offset;
  src = (dir == to_mem_obj) ? addr : va;
  dest = (dir == to_mem_obj) ? va : addr;

  bytes = buf->size - offset;

  if (bytes > length)
   bytes = length;

  if (crcp)
   crc = crc32_le(crc, src, bytes);

  memcpy(dest, src, bytes);

  length -= bytes;
  addr += bytes;

  offset = 0;
  buf++;
  i++;

  if (i == RXE_BUF_PER_MAP){
   i = 0;
   map++;
   buf = map[0]->buf;
  }
 }

 if (crcp)
  *crcp = crc;

 return 0;

err1:
 return err;
}
