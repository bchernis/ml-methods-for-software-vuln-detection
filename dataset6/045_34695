slurp_central_directory(struct archive_read *a, struct _7zip *zip,
    struct _7z_header_info *header){
 const unsigned char *p;
 uint64_t next_header_offset;
 uint64_t next_header_size;
 uint32_t next_header_crc;
 ssize_t bytes_avail;
 int check_header_crc, r;

 if ((p = __archive_read_ahead(a, 32, &bytes_avail)) == NULL)
  return (ARCHIVE_FATAL);

 if ((p[0] == 'M' && p[1] == 'Z') || memcmp(p, "\x7F\x45LF", 4) == 0){

  r = skip_sfx(a, bytes_avail);
  if (r < ARCHIVE_WARN)
   return (r);
  if ((p = __archive_read_ahead(a, 32, &bytes_avail)) == NULL)
   return (ARCHIVE_FATAL);
 }
 zip->seek_base += 32;

 if (memcmp(p, _7ZIP_SIGNATURE, 6) != 0){
  archive_set_error(&a->archive, -1, "Not 7-Zip archive file");
  return (ARCHIVE_FATAL);
 }


 if (crc32(0, (const unsigned char *)p + 12, 20)
     != archive_le32dec(p + 8)){
  archive_set_error(&a->archive, -1, "Header CRC error");
  return (ARCHIVE_FATAL);
 }

 next_header_offset = archive_le64dec(p + 12);
 next_header_size = archive_le64dec(p + 20);
 next_header_crc = archive_le32dec(p + 28);

 if (next_header_size == 0)

  return (ARCHIVE_EOF);

 if (((int64_t)next_header_offset) < 0){
  archive_set_error(&a->archive, -1, "Malformed 7-Zip archive");
  return (ARCHIVE_FATAL);
 }
 __archive_read_consume(a, 32);
 if (next_header_offset != 0){
  if (bytes_avail >= (ssize_t)next_header_offset)
   __archive_read_consume(a, next_header_offset);
  else if (__archive_read_seek(a,
      next_header_offset + zip->seek_base, SEEK_SET) < 0)
   return (ARCHIVE_FATAL);
 }
 zip->stream_offset = next_header_offset;
 zip->header_offset = next_header_offset;
 zip->header_bytes_remaining = next_header_size;
 zip->header_crc32 = 0;
 zip->header_is_encoded = 0;
 zip->header_is_being_read = 1;
 zip->has_encrypted_entries = 0;
 check_header_crc = 1;

 if ((p = header_bytes(a, 1)) == NULL){
  archive_set_error(&a->archive,
      ARCHIVE_ERRNO_FILE_FORMAT,
      "Truncated 7-Zip file body");
  return (ARCHIVE_FATAL);
 }

 switch (p[0]){
 case kEncodedHeader:




  r = decode_encoded_header_info(a, &(zip->si));


  if (r == 0 && zip->header_crc32 != next_header_crc){
   archive_set_error(&a->archive, -1,
       "Damaged 7-Zip archive");
   r = -1;
  }
  if (r == 0){
   if (zip->si.ci.folders[0].digest_defined)
    next_header_crc = zip->si.ci.folders[0].digest;
   else
    check_header_crc = 0;
   if (zip->pack_stream_bytes_unconsumed)
    read_consume(a);
   r = setup_decode_folder(a, zip->si.ci.folders, 1);
   if (r == 0){
    zip->header_bytes_remaining =
     zip->folder_outbytes_remaining;
    r = seek_pack(a);
   }
  }

  free_StreamsInfo(&(zip->si));
  memset(&(zip->si), 0, sizeof(zip->si));
  if (r < 0)
   return (ARCHIVE_FATAL);
  zip->header_is_encoded = 1;
  zip->header_crc32 = 0;

 case kHeader:



  errno = 0;
  r = read_Header(a, header, zip->header_is_encoded);
  if (r < 0){
   if (errno == ENOMEM)
    archive_set_error(&a->archive, -1,
        "Couldn't allocate memory");
   else
    archive_set_error(&a->archive, -1,
        "Damaged 7-Zip archive");
   return (ARCHIVE_FATAL);
  }




  if ((p = header_bytes(a, 1)) == NULL ||*p != kEnd){
   archive_set_error(&a->archive, -1,
       "Malformed 7-Zip archive");
   return (ARCHIVE_FATAL);
  }


  if (check_header_crc && zip->header_crc32 != next_header_crc){
   archive_set_error(&a->archive, -1,
       "Malformed 7-Zip archive");
   return (ARCHIVE_FATAL);
  }
  break;
 default:
  archive_set_error(&a->archive, -1,
      "Unexpected Property ID = %X", p[0]);
  return (ARCHIVE_FATAL);
 }


 zip->pack_stream_remaining = 0;
 zip->pack_stream_index = 0;
 zip->folder_outbytes_remaining = 0;
 zip->uncompressed_buffer_bytes_remaining = 0;
 zip->pack_stream_bytes_unconsumed = 0;
 zip->header_is_being_read = 0;

 return (ARCHIVE_OK);
}
