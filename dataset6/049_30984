combineSeparateSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,
                             uint32 cols, uint32 rows, uint16 spp, uint16 bps,
                             FILE *dumpfile, int format, int level){
  int i, bytes_per_sample;
  uint32 row, col, col_offset, src_rowsize, dst_rowsize, row_offset;
  unsigned char *src;
  unsigned char *dst;
  tsample_t s;

  src = srcbuffs[0];
  dst = out;
  if ((src == NULL) || (dst == NULL)){
    TIFFError("combineSeparateSamplesBytes","Invalid buffer address");
    return (1);
    }

  bytes_per_sample = (bps + 7) / 8;

  src_rowsize = ((bps * cols) + 7) / 8;
  dst_rowsize = ((bps * spp * cols) + 7) / 8;
  for (row = 0; row < rows; row++){
    if ((dumpfile != NULL) && (level == 2)){
      for (s = 0; s < spp; s++){
        dump_info (dumpfile, format, "combineSeparateSamplesBytes","Input data, Sample %d", s);
        dump_buffer(dumpfile, format, 1, cols, row, srcbuffs[s] + (row * src_rowsize));
        }
      }
    dst = out + (row * dst_rowsize);
    row_offset = row * src_rowsize;
    for (col = 0; col < cols; col++){
      col_offset = row_offset + (col * (bps / 8));
      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++){
        src = srcbuffs[s] + col_offset;
        for (i = 0; i < bytes_per_sample; i++)
          *(dst + i) = *(src + i);
        src += bytes_per_sample;
        dst += bytes_per_sample;
        }
      }

    if ((dumpfile != NULL) && (level == 2)){
      dump_info (dumpfile, format, "combineSeparateSamplesBytes","Output data, combined samples");
      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));
      }
    }

  return (0);
  }

static int
combineSeparateSamples8bits (uint8 *in[], uint8 *out, uint32 cols,
                            uint32 rows, uint16 spp, uint16 bps,
                      FILE *dumpfile, int format, int level){
  int ready_bits = 0;

  uint32 src_rowsize, dst_rowsize, src_offset;
  uint32 bit_offset;
  uint32 row, col, src_byte = 0, src_bit = 0;
  uint8 maskbits = 0, matchbits = 0;
  uint8 buff1 = 0, buff2 = 0;
  tsample_t s;
  unsigned char *src = in[0];
  unsigned char *dst = out;
  char action[32];

  if ((src == NULL) || (dst == NULL)){
    TIFFError("combineSeparateSamples8bits","Invalid input or output buffer");
    return (1);
    }


  src_rowsize = ((bps * cols) + 7) / 8;
  dst_rowsize = ((bps * cols * spp) + 7) / 8;
  maskbits = (uint8)-1 >> ( 8 - bps);

  for (row = 0; row < rows; row++){
    ready_bits = 0;
    buff1 = buff2 = 0;
    dst = out + (row * dst_rowsize);
    src_offset = row * src_rowsize;
    for (col = 0; col < cols; col++){

      bit_offset = col * bps;
      src_byte = bit_offset / 8;
      src_bit = bit_offset % 8;

      matchbits = maskbits << (8 - src_bit - bps);

      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++){
 src = in[s] + src_offset + src_byte;
        buff1 = ((*src) & matchbits) << (src_bit);


        if (ready_bits >= 8){
          *dst++ = buff2;
          buff2 = buff1;
          ready_bits -= 8;
          strcpy (action, "Flush");
          }
        else{
          buff2 = (buff2 | (buff1 >> ready_bits));
          strcpy (action, "Update");
          }
        ready_bits += bps;

        if ((dumpfile != NULL) && (level == 3)){
          dump_info (dumpfile, format, "",
                   "Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
     row + 1, col + 1, s, src_byte, src_bit, dst - out);
          dump_byte (dumpfile, format, "Match bits", matchbits);
          dump_byte (dumpfile, format, "Src   bits", *src);
          dump_byte (dumpfile, format, "Buff1 bits", buff1);
          dump_byte (dumpfile, format, "Buff2 bits", buff2);
          dump_info (dumpfile, format, "","%s", action);
   }
        }
      }

    if (ready_bits > 0){
      buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));
      *dst++ = buff1;
      if ((dumpfile != NULL) && (level == 3)){
        dump_info (dumpfile, format, "",
          "Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
          row + 1, col + 1, src_byte, src_bit, dst - out);
                 dump_byte (dumpfile, format, "Final bits", buff1);
        }
      }

    if ((dumpfile != NULL) && (level >= 2)){
      dump_info (dumpfile, format, "combineSeparateSamples8bits","Output data");
      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));
      }
    }

  return (0);
  }

static int
combineSeparateSamples16bits (uint8 *in[], uint8 *out, uint32 cols,
                              uint32 rows, uint16 spp, uint16 bps,
                        FILE *dumpfile, int format, int level){
  int ready_bits = 0 ;
  uint32 src_rowsize, dst_rowsize;
  uint32 bit_offset, src_offset;
  uint32 row, col, src_byte = 0, src_bit = 0;
  uint16 maskbits = 0, matchbits = 0;
  uint16 buff1 = 0, buff2 = 0;
  uint8 bytebuff = 0;
  tsample_t s;
  unsigned char *src = in[0];
  unsigned char *dst = out;
  char action[8];

  if ((src == NULL) || (dst == NULL)){
    TIFFError("combineSeparateSamples16bits","Invalid input or output buffer");
    return (1);
    }


  src_rowsize = ((bps * cols) + 7) / 8;
  dst_rowsize = ((bps * cols * spp) + 7) / 8;
  maskbits = (uint16)-1 >> (16 - bps);

  for (row = 0; row < rows; row++){
    ready_bits = 0;
    buff1 = buff2 = 0;
    dst = out + (row * dst_rowsize);
    src_offset = row * src_rowsize;
    for (col = 0; col < cols; col++){

      bit_offset = col * bps;
      src_byte = bit_offset / 8;
      src_bit = bit_offset % 8;

      matchbits = maskbits << (16 - src_bit - bps);
      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++){
 src = in[s] + src_offset + src_byte;
        if (little_endian)
          buff1 = (src[0] << 8) | src[1];
        else
          buff1 = (src[1] << 8) | src[0];

 buff1 = (buff1 & matchbits) << (src_bit);


 if (ready_bits >= 8){
     bytebuff = (buff2 >> 8);
     *dst++ = bytebuff;
     ready_bits -= 8;

     buff2 = ((buff2 << 8) | (buff1 >> ready_bits));
     strcpy (action, "Flush");
   }
 else{
     bytebuff = 0;
     buff2 = (buff2 | (buff1 >> ready_bits));
     strcpy (action, "Update");
   }
 ready_bits += bps;

 if ((dumpfile != NULL) && (level == 3)){
   dump_info (dumpfile, format, "",
         "Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
         row + 1, col + 1, s, src_byte, src_bit, dst - out);

   dump_short (dumpfile, format, "Match bits", matchbits);
   dump_data (dumpfile, format, "Src   bits", src, 2);
   dump_short (dumpfile, format, "Buff1 bits", buff1);
   dump_short (dumpfile, format, "Buff2 bits", buff2);
   dump_byte (dumpfile, format, "Write byte", bytebuff);
   dump_info (dumpfile, format, "","Ready bits:  %d, %s", ready_bits, action);
   }
 }
      }


    if (ready_bits > 0){
      bytebuff = (buff2 >> 8);
      *dst++ = bytebuff;
      if ((dumpfile != NULL) && (level == 3)){
 dump_info (dumpfile, format, "",
         "Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
         row + 1, col + 1, src_byte, src_bit, dst - out);
 dump_byte (dumpfile, format, "Final bits", bytebuff);
 }
      }

    if ((dumpfile != NULL) && (level == 2)){
      dump_info (dumpfile, format, "combineSeparateSamples16bits","Output data");
      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));
      }
    }

  return (0);
  }

static int
combineSeparateSamples24bits (uint8 *in[], uint8 *out, uint32 cols,
                              uint32 rows, uint16 spp, uint16 bps,
                       FILE *dumpfile, int format, int level){
  int ready_bits = 0 ;
  uint32 src_rowsize, dst_rowsize;
  uint32 bit_offset, src_offset;
  uint32 row, col, src_byte = 0, src_bit = 0;
  uint32 maskbits = 0, matchbits = 0;
  uint32 buff1 = 0, buff2 = 0;
  uint8 bytebuff1 = 0, bytebuff2 = 0;
  tsample_t s;
  unsigned char *src = in[0];
  unsigned char *dst = out;
  char action[8];

  if ((src == NULL) || (dst == NULL)){
    TIFFError("combineSeparateSamples24bits","Invalid input or output buffer");
    return (1);
    }


  src_rowsize = ((bps * cols) + 7) / 8;
  dst_rowsize = ((bps * cols * spp) + 7) / 8;
  maskbits = (uint32)-1 >> ( 32 - bps);

  for (row = 0; row < rows; row++){
    ready_bits = 0;
    buff1 = buff2 = 0;
    dst = out + (row * dst_rowsize);
    src_offset = row * src_rowsize;
    for (col = 0; col < cols; col++){

      bit_offset = col * bps;
      src_byte = bit_offset / 8;
      src_bit = bit_offset % 8;

      matchbits = maskbits << (32 - src_bit - bps);
      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++){
 src = in[s] + src_offset + src_byte;
        if (little_endian)
   buff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];
        else
   buff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];
 buff1 = (buff1 & matchbits) << (src_bit);


 if (ready_bits >= 16){
     bytebuff1 = (buff2 >> 24);
     *dst++ = bytebuff1;
     bytebuff2 = (buff2 >> 16);
     *dst++ = bytebuff2;
     ready_bits -= 16;


     buff2 = ((buff2 << 16) | (buff1 >> ready_bits));
     strcpy (action, "Flush");
   }
 else{
     bytebuff1 = bytebuff2 = 0;
     buff2 = (buff2 | (buff1 >> ready_bits));
     strcpy (action, "Update");
   }
 ready_bits += bps;

 if ((dumpfile != NULL) && (level == 3)){
   dump_info (dumpfile, format, "",
         "Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
         row + 1, col + 1, s, src_byte, src_bit, dst - out);
   dump_long (dumpfile, format, "Match bits ", matchbits);
   dump_data (dumpfile, format, "Src   bits ", src, 4);
   dump_long (dumpfile, format, "Buff1 bits ", buff1);
   dump_long (dumpfile, format, "Buff2 bits ", buff2);
   dump_byte (dumpfile, format, "Write bits1", bytebuff1);
   dump_byte (dumpfile, format, "Write bits2", bytebuff2);
   dump_info (dumpfile, format, "","Ready bits:   %d, %s", ready_bits, action);
   }
 }
      }


    while (ready_bits > 0){
 bytebuff1 = (buff2 >> 24);
 *dst++ = bytebuff1;

 buff2 = (buff2 << 8);
 bytebuff2 = bytebuff1;
 ready_bits -= 8;
      }

    if ((dumpfile != NULL) && (level == 3)){
      dump_info (dumpfile, format, "",
     "Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
     row + 1, col + 1, src_byte, src_bit, dst - out);

      dump_long (dumpfile, format, "Match bits ", matchbits);
      dump_data (dumpfile, format, "Src   bits ", src, 4);
      dump_long (dumpfile, format, "Buff1 bits ", buff1);
      dump_long (dumpfile, format, "Buff2 bits ", buff2);
      dump_byte (dumpfile, format, "Write bits1", bytebuff1);
      dump_byte (dumpfile, format, "Write bits2", bytebuff2);
      dump_info (dumpfile, format, "", "Ready bits:  %2d", ready_bits);
      }

    if ((dumpfile != NULL) && (level == 2)){
      dump_info (dumpfile, format, "combineSeparateSamples24bits","Output data");
      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));
      }
    }

  return (0);
  }

static int
combineSeparateSamples32bits (uint8 *in[], uint8 *out, uint32 cols,
                              uint32 rows, uint16 spp, uint16 bps,
                       FILE *dumpfile, int format, int level){
  int ready_bits = 0 ;
  uint32 src_rowsize, dst_rowsize, bit_offset, src_offset;
  uint32 src_byte = 0, src_bit = 0;
  uint32 row, col;
  uint32 longbuff1 = 0, longbuff2 = 0;
  uint64 maskbits = 0, matchbits = 0;
  uint64 buff1 = 0, buff2 = 0, buff3 = 0;
  uint8 bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;
  tsample_t s;
  unsigned char *src = in[0];
  unsigned char *dst = out;
  char action[8];

  if ((src == NULL) || (dst == NULL)){
    TIFFError("combineSeparateSamples32bits","Invalid input or output buffer");
    return (1);
    }


  src_rowsize = ((bps * cols) + 7) / 8;
  dst_rowsize = ((bps * cols * spp) + 7) / 8;
  maskbits = (uint64)-1 >> ( 64 - bps);


  for (row = 0; row < rows; row++){
    ready_bits = 0;
    buff1 = buff2 = 0;
    dst = out + (row * dst_rowsize);
    src_offset = row * src_rowsize;
    for (col = 0; col < cols; col++){

      bit_offset = col * bps;
      src_byte = bit_offset / 8;
      src_bit = bit_offset % 8;

      matchbits = maskbits << (64 - src_bit - bps);
      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++){
 src = in[s] + src_offset + src_byte;
 if (little_endian){
   longbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];
          longbuff2 = longbuff1;
   }
 else{
   longbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];
          longbuff2 = longbuff1;
   }
 buff3 = ((uint64)longbuff1 << 32) | longbuff2;
 buff1 = (buff3 & matchbits) << (src_bit);


 if (ready_bits >= 32){
   bytebuff1 = (buff2 >> 56);
   *dst++ = bytebuff1;
   bytebuff2 = (buff2 >> 48);
   *dst++ = bytebuff2;
   bytebuff3 = (buff2 >> 40);
   *dst++ = bytebuff3;
   bytebuff4 = (buff2 >> 32);
   *dst++ = bytebuff4;
   ready_bits -= 32;


   buff2 = ((buff2 << 32) | (buff1 >> ready_bits));
   strcpy (action, "Flush");
   }
 else{
   bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;
   buff2 = (buff2 | (buff1 >> ready_bits));
   strcpy (action, "Update");
   }
 ready_bits += bps;

 if ((dumpfile != NULL) && (level == 3)){
   dump_info (dumpfile, format, "",
       "Row %3d, Col %3d, Sample %d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
       row + 1, col + 1, s, src_byte, src_bit, dst - out);
   dump_wide (dumpfile, format, "Match bits ", matchbits);
   dump_data (dumpfile, format, "Src   bits ", src, 8);
   dump_wide (dumpfile, format, "Buff1 bits ", buff1);
   dump_wide (dumpfile, format, "Buff2 bits ", buff2);
   dump_info (dumpfile, format, "", "Ready bits:   %d, %s", ready_bits, action);
   }
 }
      }
    while (ready_bits > 0){
      bytebuff1 = (buff2 >> 56);
      *dst++ = bytebuff1;
      buff2 = (buff2 << 8);
      ready_bits -= 8;
      }

    if ((dumpfile != NULL) && (level == 3)){
      dump_info (dumpfile, format, "",
          "Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
   row + 1, col + 1, src_byte, src_bit, dst - out);

      dump_long (dumpfile, format, "Match bits ", matchbits);
      dump_data (dumpfile, format, "Src   bits ", src, 4);
      dump_long (dumpfile, format, "Buff1 bits ", buff1);
      dump_long (dumpfile, format, "Buff2 bits ", buff2);
      dump_byte (dumpfile, format, "Write bits1", bytebuff1);
      dump_byte (dumpfile, format, "Write bits2", bytebuff2);
      dump_info (dumpfile, format, "", "Ready bits:  %2d", ready_bits);
      }

    if ((dumpfile != NULL) && (level == 2)){
      dump_info (dumpfile, format, "combineSeparateSamples32bits","Output data");
      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);
      }
    }

  return (0);
  }

static int
combineSeparateTileSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,
                                 uint32 cols, uint32 rows, uint32 imagewidth,
                                 uint32 tw, uint16 spp, uint16 bps,
                                 FILE *dumpfile, int format, int level){
  int i, bytes_per_sample;
  uint32 row, col, col_offset, src_rowsize, dst_rowsize, src_offset;
  unsigned char *src;
  unsigned char *dst;
  tsample_t s;

  src = srcbuffs[0];
  dst = out;
  if ((src == NULL) || (dst == NULL)){
    TIFFError("combineSeparateTileSamplesBytes","Invalid buffer address");
    return (1);
    }

  bytes_per_sample = (bps + 7) / 8;
  src_rowsize = ((bps * tw) + 7) / 8;
  dst_rowsize = imagewidth * bytes_per_sample * spp;
  for (row = 0; row < rows; row++){
    if ((dumpfile != NULL) && (level == 2)){
      for (s = 0; s < spp; s++){
        dump_info (dumpfile, format, "combineSeparateTileSamplesBytes","Input data, Sample %d", s);
        dump_buffer(dumpfile, format, 1, cols, row, srcbuffs[s] + (row * src_rowsize));
        }
      }
    dst = out + (row * dst_rowsize);
    src_offset = row * src_rowsize;
#ifdef DEVELMODE
    TIFFError("","Tile row %4d, Src offset %6d   Dst offset %6d",
              row, src_offset, dst - out);
#endif
    for (col = 0; col < cols; col++){
      col_offset = src_offset + (col * (bps / 8));
      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++){
        src = srcbuffs[s] + col_offset;
        for (i = 0; i < bytes_per_sample; i++)
          *(dst + i) = *(src + i);
        dst += bytes_per_sample;
        }
      }

    if ((dumpfile != NULL) && (level == 2)){
      dump_info (dumpfile, format, "combineSeparateTileSamplesBytes","Output data, combined samples");
      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));
      }
    }

  return (0);
  }

static int
combineSeparateTileSamples8bits (uint8 *in[], uint8 *out, uint32 cols,
                                 uint32 rows, uint32 imagewidth,
                                 uint32 tw, uint16 spp, uint16 bps,
                           FILE *dumpfile, int format, int level){
  int ready_bits = 0;
  uint32 src_rowsize, dst_rowsize, src_offset;
  uint32 bit_offset;
  uint32 row, col, src_byte = 0, src_bit = 0;
  uint8 maskbits = 0, matchbits = 0;
  uint8 buff1 = 0, buff2 = 0;
  tsample_t s;
  unsigned char *src = in[0];
  unsigned char *dst = out;
  char action[32];

  if ((src == NULL) || (dst == NULL)){
    TIFFError("combineSeparateTileSamples8bits","Invalid input or output buffer");
    return (1);
    }

  src_rowsize = ((bps * tw) + 7) / 8;
  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;
  maskbits = (uint8)-1 >> ( 8 - bps);

  for (row = 0; row < rows; row++){
    ready_bits = 0;
    buff1 = buff2 = 0;
    dst = out + (row * dst_rowsize);
    src_offset = row * src_rowsize;
    for (col = 0; col < cols; col++){

      bit_offset = col * bps;
      src_byte = bit_offset / 8;
      src_bit = bit_offset % 8;

      matchbits = maskbits << (8 - src_bit - bps);

      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++){
 src = in[s] + src_offset + src_byte;
        buff1 = ((*src) & matchbits) << (src_bit);


        if (ready_bits >= 8){
          *dst++ = buff2;
          buff2 = buff1;
          ready_bits -= 8;
          strcpy (action, "Flush");
          }
        else{
          buff2 = (buff2 | (buff1 >> ready_bits));
          strcpy (action, "Update");
          }
        ready_bits += bps;

        if ((dumpfile != NULL) && (level == 3)){
          dump_info (dumpfile, format, "",
                   "Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
     row + 1, col + 1, s, src_byte, src_bit, dst - out);
          dump_byte (dumpfile, format, "Match bits", matchbits);
          dump_byte (dumpfile, format, "Src   bits", *src);
          dump_byte (dumpfile, format, "Buff1 bits", buff1);
          dump_byte (dumpfile, format, "Buff2 bits", buff2);
          dump_info (dumpfile, format, "","%s", action);
   }
        }
      }

    if (ready_bits > 0){
      buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));
      *dst++ = buff1;
      if ((dumpfile != NULL) && (level == 3)){
        dump_info (dumpfile, format, "",
          "Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
          row + 1, col + 1, src_byte, src_bit, dst - out);
                 dump_byte (dumpfile, format, "Final bits", buff1);
        }
      }

    if ((dumpfile != NULL) && (level >= 2)){
      dump_info (dumpfile, format, "combineSeparateTileSamples8bits","Output data");
      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));
      }
    }

  return (0);
  }

static int
combineSeparateTileSamples16bits (uint8 *in[], uint8 *out, uint32 cols,
                                  uint32 rows, uint32 imagewidth,
                                  uint32 tw, uint16 spp, uint16 bps,
                            FILE *dumpfile, int format, int level){
  int ready_bits = 0;
  uint32 src_rowsize, dst_rowsize;
  uint32 bit_offset, src_offset;
  uint32 row, col, src_byte = 0, src_bit = 0;
  uint16 maskbits = 0, matchbits = 0;
  uint16 buff1 = 0, buff2 = 0;
  uint8 bytebuff = 0;
  tsample_t s;
  unsigned char *src = in[0];
  unsigned char *dst = out;
  char action[8];

  if ((src == NULL) || (dst == NULL)){
    TIFFError("combineSeparateTileSamples16bits","Invalid input or output buffer");
    return (1);
    }

  src_rowsize = ((bps * tw) + 7) / 8;
  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;
  maskbits = (uint16)-1 >> (16 - bps);

  for (row = 0; row < rows; row++){
    ready_bits = 0;
    buff1 = buff2 = 0;
    dst = out + (row * dst_rowsize);
    src_offset = row * src_rowsize;
    for (col = 0; col < cols; col++){

      bit_offset = col * bps;
      src_byte = bit_offset / 8;
      src_bit = bit_offset % 8;

      matchbits = maskbits << (16 - src_bit - bps);
      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++){
 src = in[s] + src_offset + src_byte;
        if (little_endian)
          buff1 = (src[0] << 8) | src[1];
        else
          buff1 = (src[1] << 8) | src[0];
 buff1 = (buff1 & matchbits) << (src_bit);


 if (ready_bits >= 8){
     bytebuff = (buff2 >> 8);
     *dst++ = bytebuff;
     ready_bits -= 8;

     buff2 = ((buff2 << 8) | (buff1 >> ready_bits));
     strcpy (action, "Flush");
   }
 else{
     bytebuff = 0;
     buff2 = (buff2 | (buff1 >> ready_bits));
     strcpy (action, "Update");
   }
 ready_bits += bps;

 if ((dumpfile != NULL) && (level == 3)){
   dump_info (dumpfile, format, "",
         "Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
         row + 1, col + 1, s, src_byte, src_bit, dst - out);

   dump_short (dumpfile, format, "Match bits", matchbits);
   dump_data (dumpfile, format, "Src   bits", src, 2);
   dump_short (dumpfile, format, "Buff1 bits", buff1);
   dump_short (dumpfile, format, "Buff2 bits", buff2);
   dump_byte (dumpfile, format, "Write byte", bytebuff);
   dump_info (dumpfile, format, "","Ready bits:  %d, %s", ready_bits, action);
   }
 }
      }


    if (ready_bits > 0){
      bytebuff = (buff2 >> 8);
      *dst++ = bytebuff;
      if ((dumpfile != NULL) && (level == 3)){
 dump_info (dumpfile, format, "",
         "Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
         row + 1, col + 1, src_byte, src_bit, dst - out);
 dump_byte (dumpfile, format, "Final bits", bytebuff);
 }
      }

    if ((dumpfile != NULL) && (level == 2)){
      dump_info (dumpfile, format, "combineSeparateTileSamples16bits","Output data");
      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));
      }
    }

  return (0);
  }

static int
combineSeparateTileSamples24bits (uint8 *in[], uint8 *out, uint32 cols,
                                  uint32 rows, uint32 imagewidth,
                                  uint32 tw, uint16 spp, uint16 bps,
                            FILE *dumpfile, int format, int level){
  int ready_bits = 0;
  uint32 src_rowsize, dst_rowsize;
  uint32 bit_offset, src_offset;
  uint32 row, col, src_byte = 0, src_bit = 0;
  uint32 maskbits = 0, matchbits = 0;
  uint32 buff1 = 0, buff2 = 0;
  uint8 bytebuff1 = 0, bytebuff2 = 0;
  tsample_t s;
  unsigned char *src = in[0];
  unsigned char *dst = out;
  char action[8];

  if ((src == NULL) || (dst == NULL)){
    TIFFError("combineSeparateTileSamples24bits","Invalid input or output buffer");
    return (1);
    }

  src_rowsize = ((bps * tw) + 7) / 8;
  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;
  maskbits = (uint32)-1 >> ( 32 - bps);

  for (row = 0; row < rows; row++){
    ready_bits = 0;
    buff1 = buff2 = 0;
    dst = out + (row * dst_rowsize);
    src_offset = row * src_rowsize;
    for (col = 0; col < cols; col++){

      bit_offset = col * bps;
      src_byte = bit_offset / 8;
      src_bit = bit_offset % 8;

      matchbits = maskbits << (32 - src_bit - bps);
      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++){
 src = in[s] + src_offset + src_byte;
        if (little_endian)
   buff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];
        else
   buff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];
 buff1 = (buff1 & matchbits) << (src_bit);


 if (ready_bits >= 16){
     bytebuff1 = (buff2 >> 24);
     *dst++ = bytebuff1;
     bytebuff2 = (buff2 >> 16);
     *dst++ = bytebuff2;
     ready_bits -= 16;


     buff2 = ((buff2 << 16) | (buff1 >> ready_bits));
     strcpy (action, "Flush");
   }
 else{
     bytebuff1 = bytebuff2 = 0;
     buff2 = (buff2 | (buff1 >> ready_bits));
     strcpy (action, "Update");
   }
 ready_bits += bps;

 if ((dumpfile != NULL) && (level == 3)){
   dump_info (dumpfile, format, "",
         "Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
         row + 1, col + 1, s, src_byte, src_bit, dst - out);
   dump_long (dumpfile, format, "Match bits ", matchbits);
   dump_data (dumpfile, format, "Src   bits ", src, 4);
   dump_long (dumpfile, format, "Buff1 bits ", buff1);
   dump_long (dumpfile, format, "Buff2 bits ", buff2);
   dump_byte (dumpfile, format, "Write bits1", bytebuff1);
   dump_byte (dumpfile, format, "Write bits2", bytebuff2);
   dump_info (dumpfile, format, "","Ready bits:   %d, %s", ready_bits, action);
   }
 }
      }


    while (ready_bits > 0){
 bytebuff1 = (buff2 >> 24);
 *dst++ = bytebuff1;

 buff2 = (buff2 << 8);
 bytebuff2 = bytebuff1;
 ready_bits -= 8;
      }

    if ((dumpfile != NULL) && (level == 3)){
      dump_info (dumpfile, format, "",
     "Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
     row + 1, col + 1, src_byte, src_bit, dst - out);

      dump_long (dumpfile, format, "Match bits ", matchbits);
      dump_data (dumpfile, format, "Src   bits ", src, 4);
      dump_long (dumpfile, format, "Buff1 bits ", buff1);
      dump_long (dumpfile, format, "Buff2 bits ", buff2);
      dump_byte (dumpfile, format, "Write bits1", bytebuff1);
      dump_byte (dumpfile, format, "Write bits2", bytebuff2);
      dump_info (dumpfile, format, "", "Ready bits:  %2d", ready_bits);
      }

    if ((dumpfile != NULL) && (level == 2)){
      dump_info (dumpfile, format, "combineSeparateTileSamples24bits","Output data");
      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));
      }
    }

  return (0);
  }

static int
combineSeparateTileSamples32bits (uint8 *in[], uint8 *out, uint32 cols,
                                  uint32 rows, uint32 imagewidth,
                                  uint32 tw, uint16 spp, uint16 bps,
                            FILE *dumpfile, int format, int level){
  int ready_bits = 0 ;
  uint32 src_rowsize, dst_rowsize, bit_offset, src_offset;
  uint32 src_byte = 0, src_bit = 0;
  uint32 row, col;
  uint32 longbuff1 = 0, longbuff2 = 0;
  uint64 maskbits = 0, matchbits = 0;
  uint64 buff1 = 0, buff2 = 0, buff3 = 0;
  uint8 bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;
  tsample_t s;
  unsigned char *src = in[0];
  unsigned char *dst = out;
  char action[8];

  if ((src == NULL) || (dst == NULL)){
    TIFFError("combineSeparateTileSamples32bits","Invalid input or output buffer");
    return (1);
    }

  src_rowsize = ((bps * tw) + 7) / 8;
  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;
  maskbits = (uint64)-1 >> ( 64 - bps);


  for (row = 0; row < rows; row++){
    ready_bits = 0;
    buff1 = buff2 = 0;
    dst = out + (row * dst_rowsize);
    src_offset = row * src_rowsize;
    for (col = 0; col < cols; col++){

      bit_offset = col * bps;
      src_byte = bit_offset / 8;
      src_bit = bit_offset % 8;

      matchbits = maskbits << (64 - src_bit - bps);
      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++){
 src = in[s] + src_offset + src_byte;
 if (little_endian){
   longbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];
   longbuff2 = longbuff1;
   }
 else{
   longbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];
          longbuff2 = longbuff1;
   }

 buff3 = ((uint64)longbuff1 << 32) | longbuff2;
 buff1 = (buff3 & matchbits) << (src_bit);


 if (ready_bits >= 32){
   bytebuff1 = (buff2 >> 56);
   *dst++ = bytebuff1;
   bytebuff2 = (buff2 >> 48);
   *dst++ = bytebuff2;
   bytebuff3 = (buff2 >> 40);
   *dst++ = bytebuff3;
   bytebuff4 = (buff2 >> 32);
   *dst++ = bytebuff4;
   ready_bits -= 32;


   buff2 = ((buff2 << 32) | (buff1 >> ready_bits));
   strcpy (action, "Flush");
   }
 else{
   bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;
   buff2 = (buff2 | (buff1 >> ready_bits));
   strcpy (action, "Update");
   }
 ready_bits += bps;

 if ((dumpfile != NULL) && (level == 3)){
   dump_info (dumpfile, format, "",
       "Row %3d, Col %3d, Sample %d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
       row + 1, col + 1, s, src_byte, src_bit, dst - out);
   dump_wide (dumpfile, format, "Match bits ", matchbits);
   dump_data (dumpfile, format, "Src   bits ", src, 8);
   dump_wide (dumpfile, format, "Buff1 bits ", buff1);
   dump_wide (dumpfile, format, "Buff2 bits ", buff2);
   dump_info (dumpfile, format, "", "Ready bits:   %d, %s", ready_bits, action);
   }
 }
      }
    while (ready_bits > 0){
      bytebuff1 = (buff2 >> 56);
      *dst++ = bytebuff1;
      buff2 = (buff2 << 8);
      ready_bits -= 8;
      }

    if ((dumpfile != NULL) && (level == 3)){
      dump_info (dumpfile, format, "",
          "Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
   row + 1, col + 1, src_byte, src_bit, dst - out);

      dump_long (dumpfile, format, "Match bits ", matchbits);
      dump_data (dumpfile, format, "Src   bits ", src, 4);
      dump_long (dumpfile, format, "Buff1 bits ", buff1);
      dump_long (dumpfile, format, "Buff2 bits ", buff2);
      dump_byte (dumpfile, format, "Write bits1", bytebuff1);
      dump_byte (dumpfile, format, "Write bits2", bytebuff2);
      dump_info (dumpfile, format, "", "Ready bits:  %2d", ready_bits);
      }

    if ((dumpfile != NULL) && (level == 2)){
      dump_info (dumpfile, format, "combineSeparateTileSamples32bits","Output data");
      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);
      }
    }

  return (0);
  }


static int readSeparateStripsIntoBuffer (TIFF *in, uint8 *obuf, uint32 length,
                                         uint32 width, uint16 spp,
                                         struct dump_opts *dump){
  int i, bytes_per_sample, bytes_per_pixel, shift_width, result = 1;
  uint32 j;
  int32 bytes_read = 0;
  uint16 bps, planar;
  uint32 nstrips;
  uint32 strips_per_sample;
  uint32 src_rowsize, dst_rowsize, rows_processed, rps;
  uint32 rows_this_strip = 0;
  tsample_t s;
  tstrip_t strip;
  tsize_t scanlinesize = TIFFScanlineSize(in);
  tsize_t stripsize = TIFFStripSize(in);
  unsigned char *srcbuffs[MAX_SAMPLES];
  unsigned char *buff = NULL;
  unsigned char *dst = NULL;

  if (obuf == NULL){
    TIFFError("readSeparateStripsIntoBuffer","Invalid buffer argument");
    return (0);
    }

  memset (srcbuffs, '\0', sizeof(srcbuffs));
  TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);
  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);
  TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);
  if (rps > length)
    rps = length;

  bytes_per_sample = (bps + 7) / 8;
  bytes_per_pixel = ((bps * spp) + 7) / 8;
  if (bytes_per_pixel < (bytes_per_sample + 1))
    shift_width = bytes_per_pixel;
  else
    shift_width = bytes_per_sample + 1;

  src_rowsize = ((bps * width) + 7) / 8;
  dst_rowsize = ((bps * width * spp) + 7) / 8;
  dst = obuf;

  if ((dump->infile != NULL) && (dump->level == 3)){
    dump_info (dump->infile, dump->format, "",
                "Image width %d, length %d, Scanline size, %4d bytes",
                width, length, scanlinesize);
    dump_info (dump->infile, dump->format, "",
                "Bits per sample %d, Samples per pixel %d, Shift width %d",
  bps, spp, shift_width);
    }






  nstrips = TIFFNumberOfStrips(in);
  strips_per_sample = nstrips /spp;

  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++){
    srcbuffs[s] = NULL;
    buff = _TIFFmalloc(stripsize);
    if (!buff){
      TIFFError ("readSeparateStripsIntoBuffer",
                 "Unable to allocate strip read buffer for sample %d", s);
      for (i = 0; i < s; i++)
        _TIFFfree (srcbuffs[i]);
      return 0;
      }
    srcbuffs[s] = buff;
    }

  rows_processed = 0;
  for (j = 0; (j < strips_per_sample) && (result == 1); j++){
    for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++){
      buff = srcbuffs[s];
      strip = (s * strips_per_sample) + j;
      bytes_read = TIFFReadEncodedStrip (in, strip, buff, stripsize);
      rows_this_strip = bytes_read / src_rowsize;
      if (bytes_read < 0 && !ignore){
        TIFFError(TIFFFileName(in),
           "Error, can't read strip %lu for sample %d",
             (unsigned long) strip, s + 1);
        result = 0;
        break;
        }
#ifdef DEVELMODE
      TIFFError("", "Strip %2d, read %5d bytes for %4d scanlines, shift width %d",
  strip, bytes_read, rows_this_strip, shift_width);
#endif
      }

    if (rps > rows_this_strip)
      rps = rows_this_strip;
    dst = obuf + (dst_rowsize * rows_processed);
    if ((bps % 8) == 0){
      if (combineSeparateSamplesBytes (srcbuffs, dst, width, rps,
                                       spp, bps, dump->infile,
                                       dump->format, dump->level)){
        result = 0;
        break;
 }
      }
    else{
      switch (shift_width){
        case 1: if (combineSeparateSamples8bits (srcbuffs, dst, width, rps,
                                                 spp, bps, dump->infile,
                                                 dump->format, dump->level)){
                  result = 0;
                  break;
                 }
         break;
        case 2: if (combineSeparateSamples16bits (srcbuffs, dst, width, rps,
                                                  spp, bps, dump->infile,
                                                  dump->format, dump->level)){
                  result = 0;
                  break;
    }
         break;
        case 3: if (combineSeparateSamples24bits (srcbuffs, dst, width, rps,
                                                  spp, bps, dump->infile,
                                                  dump->format, dump->level)){
                  result = 0;
                  break;
                  }
                break;
        case 4:
        case 5:
        case 6:
        case 7:
        case 8: if (combineSeparateSamples32bits (srcbuffs, dst, width, rps,
                                                  spp, bps, dump->infile,
                                                  dump->format, dump->level)){
                  result = 0;
                  break;
    }
         break;
        default: TIFFError ("readSeparateStripsIntoBuffer", "Unsupported bit depth: %d", bps);
                  result = 0;
                  break;
        }
      }

    if ((rows_processed + rps) > length){
      rows_processed = length;
      rps = length - rows_processed;
      }
    else
      rows_processed += rps;
    }




  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++){
    buff = srcbuffs[s];
    if (buff != NULL)
      _TIFFfree(buff);
    }

  return (result);
  }

static int
get_page_geometry (char *name, struct pagedef *page){
    char *ptr;
    int n;

    for (ptr = name; *ptr; ptr++)
      *ptr = (char)tolower((int)*ptr);

    for (n = 0; n < MAX_PAPERNAMES; n++){
      if (strcmp(name, PaperTable[n].name) == 0){
 page->width = PaperTable[n].width;
 page->length = PaperTable[n].length;
        strncpy (page->name, PaperTable[n].name, 15);
        page->name[15] = '\0';
        return (0);
        }
      }

  return (1);
  }


static void
initPageSetup (struct pagedef *page, struct pageseg *pagelist,
               struct buffinfo seg_buffs[]){
   int i;

   strcpy (page->name, "");
   page->mode = PAGE_MODE_NONE;
   page->res_unit = RESUNIT_NONE;
   page->hres = 0.0;
   page->vres = 0.0;
   page->width = 0.0;
   page->length = 0.0;
   page->hmargin = 0.0;
   page->vmargin = 0.0;
   page->rows = 0;
   page->cols = 0;
   page->orient = ORIENTATION_NONE;

   for (i = 0; i < MAX_SECTIONS; i++){
     pagelist[i].x1 = (uint32)0;
     pagelist[i].x2 = (uint32)0;
     pagelist[i].y1 = (uint32)0;
     pagelist[i].y2 = (uint32)0;
     pagelist[i].buffsize = (uint32)0;
     pagelist[i].position = 0;
     pagelist[i].total = 0;
     }

   for (i = 0; i < MAX_OUTBUFFS; i++){
     seg_buffs[i].size = 0;
     seg_buffs[i].buffer = NULL;
     }
   }

static void
initImageData (struct image_data *image){
  image->xres = 0.0;
  image->yres = 0.0;
  image->width = 0;
  image->length = 0;
  image->res_unit = RESUNIT_NONE;
  image->bps = 0;
  image->spp = 0;
  image->planar = 0;
  image->photometric = 0;
  image->orientation = 0;
  image->compression = COMPRESSION_NONE;
  image->adjustments = 0;
  }

static void
initCropMasks (struct crop_mask *cps){
   int i;

   cps->crop_mode = CROP_NONE;
   cps->res_unit = RESUNIT_NONE;
   cps->edge_ref = EDGE_TOP;
   cps->width = 0;
   cps->length = 0;
   for (i = 0; i < 4; i++)
     cps->margins[i] = 0.0;
   cps->bufftotal = (uint32)0;
   cps->combined_width = (uint32)0;
   cps->combined_length = (uint32)0;
   cps->rotation = (uint16)0;
   cps->photometric = INVERT_DATA_AND_TAG;
   cps->mirror = (uint16)0;
   cps->invert = (uint16)0;
   cps->zones = (uint32)0;
   cps->regions = (uint32)0;
   for (i = 0; i < MAX_REGIONS; i++){
     cps->corners[i].X1 = 0.0;
     cps->corners[i].X2 = 0.0;
     cps->corners[i].Y1 = 0.0;
     cps->corners[i].Y2 = 0.0;
     cps->regionlist[i].x1 = 0;
     cps->regionlist[i].x2 = 0;
     cps->regionlist[i].y1 = 0;
     cps->regionlist[i].y2 = 0;
     cps->regionlist[i].width = 0;
     cps->regionlist[i].length = 0;
     cps->regionlist[i].buffsize = 0;
     cps->regionlist[i].buffptr = NULL;
     cps->zonelist[i].position = 0;
     cps->zonelist[i].total = 0;
     }
   cps->exp_mode = ONE_FILE_COMPOSITE;
   cps->img_mode = COMPOSITE_IMAGES;
   }

static void initDumpOptions(struct dump_opts *dump){
  dump->debug = 0;
  dump->format = DUMP_NONE;
  dump->level = 1;
  sprintf (dump->mode, "w");
  memset (dump->infilename, '\0', PATH_MAX + 1);
  memset (dump->outfilename, '\0',PATH_MAX + 1);
  dump->infile = NULL;
  dump->outfile = NULL;
  }


static int
computeInputPixelOffsets(struct crop_mask *crop, struct image_data *image,
                         struct offset *off){
  double scale;
  float xres, yres;


  uint32 tmargin, bmargin, lmargin, rmargin;
  uint32 startx, endx;
  uint32 starty, endy;
  uint32 width, length, crop_width, crop_length;
  uint32 i, max_width, max_length, zwidth, zlength, buffsize;
  uint32 x1, x2, y1, y2;

  if (image->res_unit != RESUNIT_INCH && image->res_unit != RESUNIT_CENTIMETER){
    xres = 1.0;
    yres = 1.0;
    }
  else{
    if (((image->xres == 0) || (image->yres == 0)) &&
         (crop->res_unit != RESUNIT_NONE) &&
 ((crop->crop_mode & CROP_REGIONS) || (crop->crop_mode & CROP_MARGINS) ||
   (crop->crop_mode & CROP_LENGTH) || (crop->crop_mode & CROP_WIDTH))){
      TIFFError("computeInputPixelOffsets", "Cannot compute margins or fixed size sections without image resolution");
      TIFFError("computeInputPixelOffsets", "Specify units in pixels and try again");
      return (-1);
      }
    xres = image->xres;
    yres = image->yres;
    }


  scale = 1.0;
  switch (crop->res_unit){
    case RESUNIT_CENTIMETER:
         if (image->res_unit == RESUNIT_INCH)
    scale = 1.0/2.54;
  break;
    case RESUNIT_INCH:
  if (image->res_unit == RESUNIT_CENTIMETER)
      scale = 2.54;
  break;
    case RESUNIT_NONE:
    default:
    break;
    }

  if (crop->crop_mode & CROP_REGIONS){
    max_width = max_length = 0;
    for (i = 0; i < crop->regions; i++){
      if ((crop->res_unit == RESUNIT_INCH) || (crop->res_unit == RESUNIT_CENTIMETER)){
 x1 = (uint32) (crop->corners[i].X1 * scale * xres);
 x2 = (uint32) (crop->corners[i].X2 * scale * xres);
 y1 = (uint32) (crop->corners[i].Y1 * scale * yres);
 y2 = (uint32) (crop->corners[i].Y2 * scale * yres);
        }
      else{
 x1 = (uint32) (crop->corners[i].X1);
 x2 = (uint32) (crop->corners[i].X2);
 y1 = (uint32) (crop->corners[i].Y1);
 y2 = (uint32) (crop->corners[i].Y2);
 }
      if (x1 < 1)
        crop->regionlist[i].x1 = 0;
      else
        crop->regionlist[i].x1 = (uint32) (x1 - 1);

      if (x2 > image->width - 1)
        crop->regionlist[i].x2 = image->width - 1;
      else
        crop->regionlist[i].x2 = (uint32) (x2 - 1);
      zwidth = crop->regionlist[i].x2 - crop->regionlist[i].x1 + 1;

      if (y1 < 1)
        crop->regionlist[i].y1 = 0;
      else
        crop->regionlist[i].y1 = (uint32) (y1 - 1);

      if (y2 > image->length - 1)
        crop->regionlist[i].y2 = image->length - 1;
      else
        crop->regionlist[i].y2 = (uint32) (y2 - 1);

      zlength = crop->regionlist[i].y2 - crop->regionlist[i].y1 + 1;

      if (zwidth > max_width)
        max_width = zwidth;
      if (zlength > max_length)
        max_length = zlength;

      buffsize = (uint32)
          (((zwidth * image->bps * image->spp + 7 ) / 8) * (zlength + 1));

      crop->regionlist[i].buffsize = buffsize;
      crop->bufftotal += buffsize;
      if (crop->img_mode == COMPOSITE_IMAGES){
        switch (crop->edge_ref){
          case EDGE_LEFT:
          case EDGE_RIGHT:
               crop->combined_length = zlength;
               crop->combined_width += zwidth;
               break;
          case EDGE_BOTTOM:
          case EDGE_TOP:
          default:
               crop->combined_width = zwidth;
               crop->combined_length += zlength;
        break;
          }
 }
      }
    return (0);
    }




  if (crop->crop_mode & CROP_MARGINS){
    if (crop->res_unit != RESUNIT_INCH && crop->res_unit != RESUNIT_CENTIMETER){
      tmargin = (uint32)(crop->margins[0]);
      lmargin = (uint32)(crop->margins[1]);
      bmargin = (uint32)(crop->margins[2]);
      rmargin = (uint32)(crop->margins[3]);
      }
    else{
      tmargin = (uint32)(crop->margins[0] * scale * yres);
      lmargin = (uint32)(crop->margins[1] * scale * xres);
      bmargin = (uint32)(crop->margins[2] * scale * yres);
      rmargin = (uint32)(crop->margins[3] * scale * xres);
      }

    if ((lmargin + rmargin) > image->width){
      TIFFError("computeInputPixelOffsets", "Combined left and right margins exceed image width");
      lmargin = (uint32) 0;
      rmargin = (uint32) 0;
      return (-1);
      }
    if ((tmargin + bmargin) > image->length){
      TIFFError("computeInputPixelOffsets", "Combined top and bottom margins exceed image length");
      tmargin = (uint32) 0;
      bmargin = (uint32) 0;
      return (-1);
      }
    }
  else{
    tmargin = (uint32) 0;
    lmargin = (uint32) 0;
    bmargin = (uint32) 0;
    rmargin = (uint32) 0;
    }


  if (crop->res_unit != RESUNIT_INCH && crop->res_unit != RESUNIT_CENTIMETER){
    if (crop->crop_mode & CROP_WIDTH)
      width = (uint32)crop->width;
    else
      width = image->width - lmargin - rmargin;

    if (crop->crop_mode & CROP_LENGTH)
      length = (uint32)crop->length;
    else
      length = image->length - tmargin - bmargin;
    }
  else{
    if (crop->crop_mode & CROP_WIDTH)
      width = (uint32)(crop->width * scale * image->xres);
    else
      width = image->width - lmargin - rmargin;

    if (crop->crop_mode & CROP_LENGTH)
      length = (uint32)(crop->length * scale * image->yres);
    else
      length = image->length - tmargin - bmargin;
    }

  off->tmargin = tmargin;
  off->bmargin = bmargin;
  off->lmargin = lmargin;
  off->rmargin = rmargin;




  switch (crop->edge_ref){
    case EDGE_BOTTOM:
         startx = lmargin;
         if ((startx + width) >= (image->width - rmargin))
           endx = image->width - rmargin - 1;
         else
           endx = startx + width - 1;

         endy = image->length - bmargin - 1;
         if ((endy - length) <= tmargin)
           starty = tmargin;
         else
           starty = endy - length + 1;
         break;
    case EDGE_RIGHT:
         endx = image->width - rmargin - 1;
         if ((endx - width) <= lmargin)
           startx = lmargin;
         else
           startx = endx - width + 1;

         starty = tmargin;
         if ((starty + length) >= (image->length - bmargin))
           endy = image->length - bmargin - 1;
         else
           endy = starty + length - 1;
         break;
    case EDGE_TOP:
    case EDGE_LEFT:
    default:
         startx = lmargin;
         if ((startx + width) >= (image->width - rmargin))
           endx = image->width - rmargin - 1;
         else
           endx = startx + width - 1;

         starty = tmargin;
         if ((starty + length) >= (image->length - bmargin))
           endy = image->length - bmargin - 1;
         else
           endy = starty + length - 1;
         break;
    }
  off->startx = startx;
  off->starty = starty;
  off->endx = endx;
  off->endy = endy;

  crop_width = endx - startx + 1;
  crop_length = endy - starty + 1;

  if (crop_width <= 0){
    TIFFError("computeInputPixelOffsets",
               "Invalid left/right margins and /or image crop width requested");
    return (-1);
    }
  if (crop_width > image->width)
    crop_width = image->width;

  if (crop_length <= 0){
    TIFFError("computeInputPixelOffsets",
              "Invalid top/bottom margins and /or image crop length requested");
    return (-1);
    }
  if (crop_length > image->length)
    crop_length = image->length;

  off->crop_width = crop_width;
  off->crop_length = crop_length;

  return (0);
  }
# 5358 "originals/113a.c"
static int
getCropOffsets(struct image_data *image, struct crop_mask *crop, struct dump_opts *dump){
  struct offset offsets;
  int i;
  int32 test;
  uint32 seg, total, need_buff = 0;
  uint32 buffsize;
  uint32 zwidth, zlength;

  memset(&offsets, '\0', sizeof(struct offset));
  crop->bufftotal = 0;
  crop->combined_width = (uint32)0;
  crop->combined_length = (uint32)0;
  crop->selections = 0;


  if ((crop->crop_mode & CROP_MARGINS) ||
      (crop->crop_mode & CROP_REGIONS) ||
      (crop->crop_mode & CROP_LENGTH) ||
      (crop->crop_mode & CROP_WIDTH)){
    if (computeInputPixelOffsets(crop, image, &offsets)){
      TIFFError ("getCropOffsets", "Unable to compute crop margins");
      return (-1);
      }
    need_buff = TRUE;
    crop->selections = crop->regions;

    if (crop->crop_mode & CROP_REGIONS)
      return (0);
    }
  else{
    offsets.tmargin = 0;
    offsets.lmargin = 0;
    offsets.bmargin = 0;
    offsets.rmargin = 0;
    offsets.crop_width = image->width;
    offsets.crop_length = image->length;
    offsets.startx = 0;
    offsets.endx = image->width - 1;
    offsets.starty = 0;
    offsets.endy = image->length - 1;
    need_buff = FALSE;
    }

  if (dump->outfile != NULL){
    dump_info (dump->outfile, dump->format, "", "Margins: Top: %d  Left: %d  Bottom: %d  Right: %d",
           offsets.tmargin, offsets.lmargin, offsets.bmargin, offsets.rmargin);
    dump_info (dump->outfile, dump->format, "", "Crop region within margins: Adjusted Width:  %6d  Length: %6d",
           offsets.crop_width, offsets.crop_length);
    }

  if (!(crop->crop_mode & CROP_ZONES)){
    if (need_buff == FALSE){
      crop->selections = 0;
      crop->combined_width = image->width;
      crop->combined_length = image->length;
      return (0);
      }
    else{



      crop->selections = 1;
      crop->zones = 1;
      crop->zonelist[0].total = 1;
      crop->zonelist[0].position = 1;
      }
    }
  else
    crop->selections = crop->zones;

  for (i = 0; i < crop->zones; i++){
    seg = crop->zonelist[i].position;
    total = crop->zonelist[i].total;

    switch (crop->edge_ref){
      case EDGE_LEFT:
           zlength = offsets.crop_length;
    crop->regionlist[i].y1 = offsets.starty;
           crop->regionlist[i].y2 = offsets.endy;

           crop->regionlist[i].x1 = offsets.startx +
                                  (uint32)(offsets.crop_width * 1.0 * (seg - 1) / total);
           test = (int32)offsets.startx +
                  (int32)(offsets.crop_width * 1.0 * seg / total);
           if (test < 1 )
             crop->regionlist[i].x2 = 0;
           else{
      if (test > (int32)(image->width - 1))
               crop->regionlist[i].x2 = image->width - 1;
             else
        crop->regionlist[i].x2 = test - 1;
             }
           zwidth = crop->regionlist[i].x2 - crop->regionlist[i].x1 + 1;


           crop->combined_length = (uint32)zlength;
           if (crop->exp_mode == COMPOSITE_IMAGES)
             crop->combined_width += (uint32)zwidth;
           else
             crop->combined_width = (uint32)zwidth;
           break;
      case EDGE_BOTTOM:
           zwidth = offsets.crop_width;
    crop->regionlist[i].x1 = offsets.startx;
           crop->regionlist[i].x2 = offsets.endx;

           test = offsets.endy - (uint32)(offsets.crop_length * 1.0 * seg / total);
           if (test < 1 )
      crop->regionlist[i].y1 = 0;
           else
      crop->regionlist[i].y1 = test + 1;

           test = offsets.endy - (offsets.crop_length * 1.0 * (seg - 1) / total);
           if (test < 1 )
             crop->regionlist[i].y2 = 0;
           else{
             if (test > (int32)(image->length - 1))
               crop->regionlist[i].y2 = image->length - 1;
             else
               crop->regionlist[i].y2 = test;
      }
           zlength = crop->regionlist[i].y2 - crop->regionlist[i].y1 + 1;


           if (crop->exp_mode == COMPOSITE_IMAGES)
             crop->combined_length += (uint32)zlength;
           else
             crop->combined_length = (uint32)zlength;
           crop->combined_width = (uint32)zwidth;
           break;
      case EDGE_RIGHT:
           zlength = offsets.crop_length;
    crop->regionlist[i].y1 = offsets.starty;
           crop->regionlist[i].y2 = offsets.endy;

           crop->regionlist[i].x1 = offsets.startx +
                                  (uint32)(offsets.crop_width * (total - seg) * 1.0 / total);
           test = offsets.startx +
           (offsets.crop_width * (total - seg + 1) * 1.0 / total);
           if (test < 1 )
             crop->regionlist[i].x2 = 0;
           else{
      if (test > (int32)(image->width - 1))
               crop->regionlist[i].x2 = image->width - 1;
             else
               crop->regionlist[i].x2 = test - 1;
             }
           zwidth = crop->regionlist[i].x2 - crop->regionlist[i].x1 + 1;


           crop->combined_length = (uint32)zlength;
           if (crop->exp_mode == COMPOSITE_IMAGES)
             crop->combined_width += (uint32)zwidth;
           else
             crop->combined_width = (uint32)zwidth;
           break;
      case EDGE_TOP:
      default:
           zwidth = offsets.crop_width;
    crop->regionlist[i].x1 = offsets.startx;
           crop->regionlist[i].x2 = offsets.endx;

           crop->regionlist[i].y1 = offsets.starty + (uint32)(offsets.crop_length * 1.0 * (seg - 1) / total);
           test = offsets.starty + (uint32)(offsets.crop_length * 1.0 * seg / total);
           if (test < 1 )
             crop->regionlist[i].y2 = 0;
           else{
      if (test > (int32)(image->length - 1))
        crop->regionlist[i].y2 = image->length - 1;
             else
        crop->regionlist[i].y2 = test - 1;
      }
           zlength = crop->regionlist[i].y2 - crop->regionlist[i].y1 + 1;


           if (crop->exp_mode == COMPOSITE_IMAGES)
             crop->combined_length += (uint32)zlength;
           else
             crop->combined_length = (uint32)zlength;
           crop->combined_width = (uint32)zwidth;
           break;
      }

    buffsize = (uint32)
          ((((zwidth * image->bps * image->spp) + 7 ) / 8) * (zlength + 1));
    crop->regionlist[i].width = (uint32) zwidth;
    crop->regionlist[i].length = (uint32) zlength;
    crop->regionlist[i].buffsize = buffsize;
    crop->bufftotal += buffsize;


  if (dump->outfile != NULL)
    dump_info (dump->outfile, dump->format, "", "Zone %d, width: %4d, length: %4d, x1: %4d  x2: %4d  y1: %4d  y2: %4d",
                    i + 1, (uint32)zwidth, (uint32)zlength,
      crop->regionlist[i].x1, crop->regionlist[i].x2,
                    crop->regionlist[i].y1, crop->regionlist[i].y2);
    }

  return (0);
  }


static int
computeOutputPixelOffsets (struct crop_mask *crop, struct image_data *image,
                           struct pagedef *page, struct pageseg *sections,
                           struct dump_opts* dump){
  double scale;
  double pwidth, plength;
  uint32 iwidth, ilength;
  uint32 owidth, olength;
  uint32 orows, ocols;
  uint32 hmargin, vmargin;
  uint32 x1, x2, y1, y2, line_bytes;

  uint32 i, j, k;

  scale = 1.0;
  if (page->res_unit == RESUNIT_NONE)
    page->res_unit = image->res_unit;

  switch (image->res_unit){
    case RESUNIT_CENTIMETER:
         if (page->res_unit == RESUNIT_INCH)
    scale = 1.0/2.54;
  break;
    case RESUNIT_INCH:
  if (page->res_unit == RESUNIT_CENTIMETER)
      scale = 2.54;
  break;
    case RESUNIT_NONE:
    default:
    break;
    }


  if (crop->combined_width > 0)
    iwidth = crop->combined_width;
  else
    iwidth = image->width;
  if (crop->combined_length > 0)
    ilength = crop->combined_length;
  else
    ilength = image->length;

  if (page->hres <= 1.0)
    page->hres = image->xres;
  if (page->vres <= 1.0)
    page->vres = image->yres;

  if ((page->hres < 1.0) || (page->vres < 1.0)){
    TIFFError("computeOutputPixelOffsets",
    "Invalid horizontal or vertical resolution specified or read from input image");
    return (1);
    }




  if (page->width <= 0)
    pwidth = iwidth;
  else
    pwidth = page->width;

  if (page->length <= 0)
    plength = ilength;
  else
    plength = page->length;

  if (dump->debug){
    TIFFError("", "Page size: %s, Vres: %3.2f, Hres: %3.2f, "
                   "Hmargin: %3.2f, Vmargin: %3.2f",
      page->name, page->vres, page->hres,
             page->hmargin, page->vmargin);
    TIFFError("", "Res_unit: %d, Scale: %3.2f, Page width: %3.2f, length: %3.2f",
           page->res_unit, scale, pwidth, plength);
    }


  if (page->mode & PAGE_MODE_MARGINS){
    if (page->res_unit == RESUNIT_INCH || page->res_unit == RESUNIT_CENTIMETER){
      hmargin = (uint32)(page->hmargin * scale * page->hres * ((image->bps + 7)/ 8));
      vmargin = (uint32)(page->vmargin * scale * page->vres * ((image->bps + 7)/ 8));
      }
    else{
      hmargin = (uint32)(page->hmargin * scale * ((image->bps + 7)/ 8));
      vmargin = (uint32)(page->vmargin * scale * ((image->bps + 7)/ 8));
      }

    if ((hmargin * 2.0) > (pwidth * page->hres)){
      TIFFError("computeOutputPixelOffsets",
                "Combined left and right margins exceed page width");
      hmargin = (uint32) 0;
      return (-1);
      }
    if ((vmargin * 2.0) > (plength * page->vres)){
      TIFFError("computeOutputPixelOffsets",
                "Combined top and bottom margins exceed page length");
      vmargin = (uint32) 0;
      return (-1);
      }
    }
  else{
    hmargin = 0;
    vmargin = 0;
    }

  if (page->mode & PAGE_MODE_ROWSCOLS ){

    if (page->mode & PAGE_MODE_MARGINS)
      TIFFError("computeOutputPixelOffsets",
      "Output margins cannot be specified with rows and columns");

    owidth = TIFFhowmany(iwidth, page->cols);
    olength = TIFFhowmany(ilength, page->rows);
    }
  else{
    if (page->mode & PAGE_MODE_PAPERSIZE ){
      owidth = (uint32)((pwidth * page->hres) - (hmargin * 2));
      olength = (uint32)((plength * page->vres) - (vmargin * 2));
      }
    else{
      owidth = (uint32)(iwidth - (hmargin * 2 * page->hres));
      olength = (uint32)(ilength - (vmargin * 2 * page->vres));
      }
    }

  if (owidth > iwidth)
    owidth = iwidth;
  if (olength > ilength)
    olength = ilength;


  switch (page->orient){
    case ORIENTATION_NONE:
    case ORIENTATION_PORTRAIT:
         ocols = TIFFhowmany(iwidth, owidth);
         orows = TIFFhowmany(ilength, olength);

         break;

    case ORIENTATION_LANDSCAPE:
         ocols = TIFFhowmany(iwidth, olength);
         orows = TIFFhowmany(ilength, owidth);
         x1 = olength;
         olength = owidth;
         owidth = x1;

         break;

    case ORIENTATION_AUTO:
    default:
         x1 = TIFFhowmany(iwidth, owidth);
         x2 = TIFFhowmany(ilength, olength);
         y1 = TIFFhowmany(iwidth, olength);
         y2 = TIFFhowmany(ilength, owidth);

         if ( (x1 * x2) < (y1 * y2)){
           ocols = x1;
           orows = x2;

    }
         else{
           ocols = y1;
           orows = y2;
           x1 = olength;
           olength = owidth;
           owidth = x1;

           }
    }

  if (ocols < 1)
    ocols = 1;
  if (orows < 1)
    orows = 1;


  if (page->rows < 1)
    page->rows = orows;
  if (page->cols < 1)
    page->cols = ocols;

  line_bytes = TIFFhowmany8(owidth * image->bps) * image->spp;

  if ((page->rows * page->cols) > MAX_SECTIONS){
   TIFFError("computeOutputPixelOffsets",
      "Rows and Columns exceed maximum sections\nIncrease resolution or reduce sections");
   return (-1);
   }


  for (k = 0, i = 0 && k <= MAX_SECTIONS; i < orows; i++){
    y1 = (uint32)(olength * i);
    y2 = (uint32)(olength * (i + 1) - 1);
    if (y2 >= ilength)
      y2 = ilength - 1;
    for (j = 0; j < ocols; j++, k++){
      x1 = (uint32)(owidth * j);
      x2 = (uint32)(owidth * (j + 1) - 1);
      if (x2 >= iwidth)
        x2 = iwidth - 1;
      sections[k].x1 = x1;
      sections[k].x2 = x2;
      sections[k].y1 = y1;
      sections[k].y2 = y2;
      sections[k].buffsize = line_bytes * olength;
      sections[k].position = k + 1;
      sections[k].total = orows * ocols;
      }
    }
  return (0);
  }

static int
loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned char **read_ptr){
  uint32 i;
  float xres = 0.0, yres = 0.0;
  uint32 nstrips = 0, ntiles = 0;
  uint16 planar = 0;
  uint16 bps = 0, spp = 0, res_unit = 0;
  uint16 orientation = 0;
  uint16 input_compression = 0, input_photometric = 0;
  uint16 subsampling_horiz, subsampling_vert;
  uint32 width = 0, length = 0;
  uint32 stsize = 0, tlsize = 0, buffsize = 0, scanlinesize = 0;
  uint32 tw = 0, tl = 0;
  uint32 tile_rowsize = 0;
  unsigned char *read_buff = NULL;
  unsigned char *new_buff = NULL;
  int readunit = 0;
  static uint32 prev_readsize = 0;

  TIFFGetFieldDefaulted(in, TIFFTAG_BITSPERSAMPLE, &bps);
  TIFFGetFieldDefaulted(in, TIFFTAG_SAMPLESPERPIXEL, &spp);
  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);
  TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);
  if (! TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric))
    TIFFError("loadImage","Image lacks Photometric interpreation tag");
  if (! TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &width))
    TIFFError("loadimage","Image lacks image width tag");
  if(! TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length))
    TIFFError("loadimage","Image lacks image length tag");
  TIFFGetFieldDefaulted(in, TIFFTAG_XRESOLUTION, &xres);
  TIFFGetFieldDefaulted(in, TIFFTAG_YRESOLUTION, &yres);
  if (!TIFFGetFieldDefaulted(in, TIFFTAG_RESOLUTIONUNIT, &res_unit))
    res_unit = RESUNIT_INCH;
  if (!TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression))
    input_compression = COMPRESSION_NONE;

#ifdef DEBUG2
  char compressionid[16];

  switch (input_compression){
    case COMPRESSION_NONE:
  strcpy (compressionid, "None/dump");
         break;
    case COMPRESSION_CCITTRLE:
  strcpy (compressionid, "Huffman RLE");
         break;
    case COMPRESSION_CCITTFAX3:
  strcpy (compressionid, "Group3 Fax");
         break;
    case COMPRESSION_CCITTFAX4:
  strcpy (compressionid, "Group4 Fax");
         break;
    case COMPRESSION_LZW:
  strcpy (compressionid, "LZW");
         break;
    case COMPRESSION_OJPEG:
  strcpy (compressionid, "Old Jpeg");
         break;
    case COMPRESSION_JPEG:
  strcpy (compressionid, "New Jpeg");
         break;
    case COMPRESSION_NEXT:
  strcpy (compressionid, "Next RLE");
         break;
    case COMPRESSION_CCITTRLEW:
  strcpy (compressionid, "CITTRLEW");
         break;
    case COMPRESSION_PACKBITS:
  strcpy (compressionid, "Mac Packbits");
         break;
    case COMPRESSION_THUNDERSCAN:
  strcpy (compressionid, "Thunderscan");
         break;
    case COMPRESSION_IT8CTPAD:
  strcpy (compressionid, "IT8 padded");
         break;
    case COMPRESSION_IT8LW:
  strcpy (compressionid, "IT8 RLE");
         break;
    case COMPRESSION_IT8MP:
  strcpy (compressionid, "IT8 mono");
         break;
    case COMPRESSION_IT8BL:
  strcpy (compressionid, "IT8 lineart");
         break;
    case COMPRESSION_PIXARFILM:
  strcpy (compressionid, "Pixar 10 bit");
         break;
    case COMPRESSION_PIXARLOG:
  strcpy (compressionid, "Pixar 11bit");
         break;
    case COMPRESSION_DEFLATE:
  strcpy (compressionid, "Deflate");
         break;
    case COMPRESSION_ADOBE_DEFLATE:
  strcpy (compressionid, "Adobe deflate");
         break;
    default:
  strcpy (compressionid, "None/unknown");
         break;
    }
  TIFFError("loadImage", "Input compression %s", compressionid);
#endif

  scanlinesize = TIFFScanlineSize(in);
  image->bps = bps;
  image->spp = spp;
  image->planar = planar;
  image->width = width;
  image->length = length;
  image->xres = xres;
  image->yres = yres;
  image->res_unit = res_unit;
  image->compression = input_compression;
  image->photometric = input_photometric;
#ifdef DEBUG2
  char photometricid[12];

  switch (input_photometric){
    case PHOTOMETRIC_MINISWHITE:
         strcpy (photometricid, "MinIsWhite");
         break;
    case PHOTOMETRIC_MINISBLACK:
         strcpy (photometricid, "MinIsBlack");
         break;
    case PHOTOMETRIC_RGB:
         strcpy (photometricid, "RGB");
         break;
    case PHOTOMETRIC_PALETTE:
         strcpy (photometricid, "Palette");
         break;
    case PHOTOMETRIC_MASK:
         strcpy (photometricid, "Mask");
         break;
    case PHOTOMETRIC_SEPARATED:
         strcpy (photometricid, "Separated");
         break;
    case PHOTOMETRIC_YCBCR:
         strcpy (photometricid, "YCBCR");
         break;
    case PHOTOMETRIC_CIELAB:
         strcpy (photometricid, "CIELab");
         break;
    case PHOTOMETRIC_ICCLAB:
         strcpy (photometricid, "ICCLab");
         break;
    case PHOTOMETRIC_ITULAB:
         strcpy (photometricid, "ITULab");
         break;
    case PHOTOMETRIC_LOGL:
         strcpy (photometricid, "LogL");
         break;
    case PHOTOMETRIC_LOGLUV:
         strcpy (photometricid, "LOGLuv");
         break;
    default:
         strcpy (photometricid, "Unknown");
         break;
    }
  TIFFError("loadImage", "Input photometric interpretation %s", photometricid);

#endif
  image->orientation = orientation;
  switch (orientation){
    case 0:
    case ORIENTATION_TOPLEFT:
         image->adjustments = 0;
  break;
    case ORIENTATION_TOPRIGHT:
         image->adjustments = MIRROR_HORIZ;
  break;
    case ORIENTATION_BOTRIGHT:
         image->adjustments = ROTATECW_180;
  break;
    case ORIENTATION_BOTLEFT:
         image->adjustments = MIRROR_VERT;
  break;
    case ORIENTATION_LEFTTOP:
         image->adjustments = MIRROR_VERT | ROTATECW_90;
  break;
    case ORIENTATION_RIGHTTOP:
         image->adjustments = ROTATECW_90;
  break;
    case ORIENTATION_RIGHTBOT:
         image->adjustments = MIRROR_VERT | ROTATECW_270;
  break;
    case ORIENTATION_LEFTBOT:
         image->adjustments = ROTATECW_270;
  break;
    default:
         image->adjustments = 0;
         image->orientation = ORIENTATION_TOPLEFT;
   }

  if ((bps == 0) || (spp == 0)){
    TIFFError("loadImage", "Invalid samples per pixel (%d) or bits per sample (%d)",
        spp, bps);
    return (-1);
    }

  if (TIFFIsTiled(in)){
    readunit = TILE;
    tlsize = TIFFTileSize(in);
    ntiles = TIFFNumberOfTiles(in);
    TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);
    TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);

    tile_rowsize = TIFFTileRowSize(in);
    if (ntiles == 0 || tlsize == 0 || tile_rowsize == 0){
 TIFFError("loadImage", "File appears to be tiled, but the number of tiles, tile size, or tile rowsize is zero.");
 exit(-1);
    }
    buffsize = tlsize * ntiles;
    if (tlsize != (buffsize / ntiles)){
 TIFFError("loadImage", "Integer overflow when calculating buffer size");
 exit(-1);
    }

    if (buffsize < (uint32)(ntiles * tl * tile_rowsize)){
      buffsize = ntiles * tl * tile_rowsize;
      if (ntiles != (buffsize / tl / tile_rowsize)){
 TIFFError("loadImage", "Integer overflow when calculating buffer size");
 exit(-1);
      }

#ifdef DEBUG2
      TIFFError("loadImage",
         "Tilesize %u is too small, using ntiles * tilelength * tilerowsize %lu",
                tlsize, (unsigned long)buffsize);
#endif
      }

    if (dump->infile != NULL)
      dump_info (dump->infile, dump->format, "",
                 "Tilesize: %u, Number of Tiles: %u, Tile row size: %u",
                 tlsize, ntiles, tile_rowsize);
    }
  else{
    uint32 buffsize_check;
    readunit = STRIP;
    TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);
    stsize = TIFFStripSize(in);
    nstrips = TIFFNumberOfStrips(in);
    if (nstrips == 0 || stsize == 0){
 TIFFError("loadImage", "File appears to be striped, but the number of stipes or stripe size is zero.");
 exit(-1);
    }

    buffsize = stsize * nstrips;
    if (stsize != (buffsize / nstrips)){
 TIFFError("loadImage", "Integer overflow when calculating buffer size");
 exit(-1);
    }
    buffsize_check = ((length * width * spp * bps) + 7);
    if (length != ((buffsize_check - 7) / width / spp / bps)){
 TIFFError("loadImage", "Integer overflow detected.");
 exit(-1);
    }
    if (buffsize < (uint32) (((length * width * spp * bps) + 7) / 8)){
      buffsize = ((length * width * spp * bps) + 7) / 8;
#ifdef DEBUG2
      TIFFError("loadImage",
         "Stripsize %u is too small, using imagelength * width * spp * bps / 8 = %lu",
                stsize, (unsigned long)buffsize);
#endif
      }

    if (dump->infile != NULL)
      dump_info (dump->infile, dump->format, "",
                 "Stripsize: %u, Number of Strips: %u, Rows per Strip: %u, Scanline size: %u",
   stsize, nstrips, rowsperstrip, scanlinesize);
    }

  if (input_compression == COMPRESSION_JPEG){
    jpegcolormode = JPEGCOLORMODE_RGB;
    TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);
    }

  else{
    if (input_photometric == PHOTOMETRIC_YCBCR){
      TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,
              &subsampling_horiz, &subsampling_vert);
      if (subsampling_horiz != 1 || subsampling_vert != 1){
 TIFFError("loadImage",
  "Can't copy/convert subsampled image with subsampling %d horiz %d vert",
                subsampling_horiz, subsampling_vert);
        return (-1);
        }
 }
    }

  read_buff = *read_ptr;


  if (!read_buff){
    if( buffsize > 0xFFFFFFFFU - 3 ){
        TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
        return (-1);
    }
    read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
  }
  else{
    if (prev_readsize < buffsize){
      if( buffsize > 0xFFFFFFFFU - 3 ){
          TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
          return (-1);
      }
      new_buff = _TIFFrealloc(read_buff, buffsize+3);
      if (!new_buff){
 free (read_buff);
        read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
        }
      else
        read_buff = new_buff;
      }
    }
  if (!read_buff){
    TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
    return (-1);
    }

  read_buff[buffsize] = 0;
  read_buff[buffsize+1] = 0;
  read_buff[buffsize+2] = 0;

  prev_readsize = buffsize;
  *read_ptr = read_buff;





  switch (readunit){
    case STRIP:
         if (planar == PLANARCONFIG_CONTIG){
      if (!(readContigStripsIntoBuffer(in, read_buff))){
      TIFFError("loadImage", "Unable to read contiguous strips into buffer");
      return (-1);
             }
           }
         else{
    if (!(readSeparateStripsIntoBuffer(in, read_buff, length, width, spp, dump))){
      TIFFError("loadImage", "Unable to read separate strips into buffer");
      return (-1);
             }
           }
         break;

    case TILE:
         if (planar == PLANARCONFIG_CONTIG){
    if (!(readContigTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps))){
      TIFFError("loadImage", "Unable to read contiguous tiles into buffer");
      return (-1);
             }
           }
         else{
    if (!(readSeparateTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps))){
      TIFFError("loadImage", "Unable to read separate tiles into buffer");
      return (-1);
             }
           }
         break;
    default: TIFFError("loadImage", "Unsupported image file format");
          return (-1);
          break;
    }
  if ((dump->infile != NULL) && (dump->level == 2)){
    dump_info (dump->infile, dump->format, "loadImage",
                "Image width %d, length %d, Raw image data, %4d bytes",
                width, length, buffsize);
    dump_info (dump->infile, dump->format, "",
                "Bits per sample %d, Samples per pixel %d", bps, spp);

    for (i = 0; i < length; i++)
      dump_buffer(dump->infile, dump->format, 1, scanlinesize,
                  i, read_buff + (i * scanlinesize));
    }
  return (0);
  }

static int correct_orientation(struct image_data *image, unsigned char **work_buff_ptr){
  uint16 mirror, rotation;
  unsigned char *work_buff;

  work_buff = *work_buff_ptr;
  if ((image == NULL) || (work_buff == NULL)){
    TIFFError ("correct_orientatin", "Invalid image or buffer pointer");
    return (-1);
    }

  if ((image->adjustments & MIRROR_HORIZ) || (image->adjustments & MIRROR_VERT)){
    mirror = (uint16)(image->adjustments & MIRROR_BOTH);
    if (mirrorImage(image->spp, image->bps, mirror,
        image->width, image->length, work_buff)){
      TIFFError ("correct_orientation", "Unable to mirror image");
      return (-1);
      }
    }

  if (image->adjustments & ROTATE_ANY){
    if (image->adjustments & ROTATECW_90)
      rotation = (uint16) 90;
    else
    if (image->adjustments & ROTATECW_180)
      rotation = (uint16) 180;
    else
    if (image->adjustments & ROTATECW_270)
      rotation = (uint16) 270;
    else{
      TIFFError ("correct_orientation", "Invalid rotation value: %d",
                  image->adjustments & ROTATE_ANY);
      return (-1);
      }

    if (rotateImage(rotation, image, &image->width, &image->length, work_buff_ptr)){
      TIFFError ("correct_orientation", "Unable to rotate image");
      return (-1);
      }
    image->orientation = ORIENTATION_TOPLEFT;
    }

  return (0);
  }



static int
extractCompositeRegions(struct image_data *image, struct crop_mask *crop,
                        unsigned char *read_buff, unsigned char *crop_buff){
  int shift_width, bytes_per_sample, bytes_per_pixel;
  uint32 i, trailing_bits, prev_trailing_bits;
  uint32 row, first_row, last_row, first_col, last_col;
  uint32 src_rowsize, dst_rowsize, src_offset, dst_offset;
  uint32 crop_width, crop_length, img_width ;
  uint32 prev_length, prev_width, composite_width;
  uint16 bps, spp;
  uint8 *src, *dst;
  tsample_t count, sample = 0;

  img_width = image->width;

  bps = image->bps;
  spp = image->spp;
  count = spp;

  bytes_per_sample = (bps + 7) / 8;
  bytes_per_pixel = ((bps * spp) + 7) / 8;
  if ((bps % 8) == 0)
    shift_width = 0;
  else{
    if (bytes_per_pixel < (bytes_per_sample + 1))
      shift_width = bytes_per_pixel;
    else
      shift_width = bytes_per_sample + 1;
    }
  src = read_buff;
  dst = crop_buff;


  prev_width = prev_length = 0;
  prev_trailing_bits = trailing_bits = 0;
  composite_width = crop->combined_width;
  crop->combined_width = 0;
  crop->combined_length = 0;

  for (i = 0; i < crop->selections; i++){

    first_row = crop->regionlist[i].y1;
    last_row = crop->regionlist[i].y2;
    first_col = crop->regionlist[i].x1;
    last_col = crop->regionlist[i].x2;

    crop_width = last_col - first_col + 1;
    crop_length = last_row - first_row + 1;


    crop->regionlist[i].width = crop_width;
    crop->regionlist[i].length = crop_length;
    crop->regionlist[i].buffptr = crop_buff;

    src_rowsize = ((img_width * bps * spp) + 7) / 8;
    dst_rowsize = (((crop_width * bps * count) + 7) / 8);

    switch (crop->edge_ref){
      default:
      case EDGE_TOP:
      case EDGE_BOTTOM:
    if ((i > 0) && (crop_width != crop->regionlist[i - 1].width)){
      TIFFError ("extractCompositeRegions",
                          "Only equal width regions can be combined for -E top or bottom");
      return (1);
             }

           crop->combined_width = crop_width;
           crop->combined_length += crop_length;

           for (row = first_row; row <= last_row; row++){
      src_offset = row * src_rowsize;
      dst_offset = (row - first_row) * dst_rowsize;
             src = read_buff + src_offset;
             dst = crop_buff + dst_offset + (prev_length * dst_rowsize);
             switch (shift_width){
               case 0: if (extractContigSamplesBytes (src, dst, img_width, sample,
                                                      spp, bps, count, first_col,
                                                      last_col + 1)){
           TIFFError("extractCompositeRegions",
                                   "Unable to extract row %d", row);
           return (1);
           }
         break;
               case 1: if (bps == 1){
                         if (extractContigSamplesShifted8bits (src, dst, img_width,
                                                               sample, spp, bps, count,
                                                               first_col, last_col + 1,
                                                               prev_trailing_bits)){
             TIFFError("extractCompositeRegions",
                                     "Unable to extract row %d", row);
             return (1);
             }
           break;
    }
                       else
                         if (extractContigSamplesShifted16bits (src, dst, img_width,
                                                                sample, spp, bps, count,
                                                                first_col, last_col + 1,
                                                                prev_trailing_bits)){
             TIFFError("extractCompositeRegions",
                                     "Unable to extract row %d", row);
             return (1);
             }
          break;
               case 2: if (extractContigSamplesShifted24bits (src, dst, img_width,
                                                               sample, spp, bps, count,
                                                               first_col, last_col + 1,
                                                               prev_trailing_bits)){
            TIFFError("extractCompositeRegions",
                                    "Unable to extract row %d", row);
            return (1);
            }
          break;
               case 3:
               case 4:
               case 5: if (extractContigSamplesShifted32bits (src, dst, img_width,
                                                               sample, spp, bps, count,
                                                               first_col, last_col + 1,
                                                               prev_trailing_bits)){
            TIFFError("extractCompositeRegions",
                                    "Unable to extract row %d", row);
            return (1);
            }
          break;
               default: TIFFError("extractCompositeRegions", "Unsupported bit depth %d", bps);
          return (1);
        }
             }
           prev_length += crop_length;
    break;
      case EDGE_LEFT:
      case EDGE_RIGHT:
    if ((i > 0) && (crop_length != crop->regionlist[i - 1].length)){
      TIFFError ("extractCompositeRegions",
                          "Only equal length regions can be combined for -E left or right");
      return (1);
             }
           crop->combined_width += crop_width;
           crop->combined_length = crop_length;
           dst_rowsize = (((composite_width * bps * count) + 7) / 8);
           trailing_bits = (crop_width * bps * count) % 8;
           for (row = first_row; row <= last_row; row++){
      src_offset = row * src_rowsize;
      dst_offset = (row - first_row) * dst_rowsize;
             src = read_buff + src_offset;
             dst = crop_buff + dst_offset + prev_width;

             switch (shift_width){
               case 0: if (extractContigSamplesBytes (src, dst, img_width,
                                                      sample, spp, bps, count,
                                                      first_col, last_col + 1)){
           TIFFError("extractCompositeRegions",
                                   "Unable to extract row %d", row);
           return (1);
           }
         break;
               case 1: if (bps == 1){
                         if (extractContigSamplesShifted8bits (src, dst, img_width,
                                                               sample, spp, bps, count,
                                                               first_col, last_col + 1,
                                                               prev_trailing_bits)){
             TIFFError("extractCompositeRegions",
                                     "Unable to extract row %d", row);
             return (1);
             }
           break;
    }
                       else
                         if (extractContigSamplesShifted16bits (src, dst, img_width,
                                                                sample, spp, bps, count,
                                                                first_col, last_col + 1,
                                                                prev_trailing_bits)){
             TIFFError("extractCompositeRegions",
                                     "Unable to extract row %d", row);
             return (1);
             }
          break;
              case 2: if (extractContigSamplesShifted24bits (src, dst, img_width,
                                                               sample, spp, bps, count,
                                                               first_col, last_col + 1,
                                                               prev_trailing_bits)){
            TIFFError("extractCompositeRegions",
                                    "Unable to extract row %d", row);
            return (1);
            }
          break;
               case 3:
               case 4:
               case 5: if (extractContigSamplesShifted32bits (src, dst, img_width,
                                                               sample, spp, bps, count,
                                                               first_col, last_col + 1,
                                                               prev_trailing_bits)){
            TIFFError("extractCompositeRegions",
                                    "Unable to extract row %d", row);
            return (1);
            }
          break;
               default: TIFFError("extractCompositeRegions", "Unsupported bit depth %d", bps);
          return (1);
        }
      }
    prev_width += (crop_width * bps * count) / 8;
           prev_trailing_bits += trailing_bits;
           if (prev_trailing_bits > 7)
      prev_trailing_bits-= 8;
    break;
      }
    }
  if (crop->combined_width != composite_width)
    TIFFError("combineSeparateRegions","Combined width does not match composite width");

  return (0);
  }
# 6521 "originals/113a.c"
static int
extractSeparateRegion(struct image_data *image, struct crop_mask *crop,
                      unsigned char *read_buff, unsigned char *crop_buff,
                      int region){
  int shift_width, prev_trailing_bits = 0;
  uint32 bytes_per_sample, bytes_per_pixel;
  uint32 src_rowsize, dst_rowsize;
  uint32 row, first_row, last_row, first_col, last_col;
  uint32 src_offset, dst_offset;
  uint32 crop_width, crop_length, img_width ;
  uint16 bps, spp;
  uint8 *src, *dst;
  tsample_t count, sample = 0;

  img_width = image->width;

  bps = image->bps;
  spp = image->spp;
  count = spp;

  bytes_per_sample = (bps + 7) / 8;
  bytes_per_pixel = ((bps * spp) + 7) / 8;
  if ((bps % 8) == 0)
    shift_width = 0;
  else{
    if (bytes_per_pixel < (bytes_per_sample + 1))
      shift_width = bytes_per_pixel;
    else
      shift_width = bytes_per_sample + 1;
    }


  first_row = crop->regionlist[region].y1;
  last_row = crop->regionlist[region].y2;
  first_col = crop->regionlist[region].x1;
  last_col = crop->regionlist[region].x2;

  crop_width = last_col - first_col + 1;
  crop_length = last_row - first_row + 1;

  crop->regionlist[region].width = crop_width;
  crop->regionlist[region].length = crop_length;
  crop->regionlist[region].buffptr = crop_buff;

  src = read_buff;
  dst = crop_buff;
  src_rowsize = ((img_width * bps * spp) + 7) / 8;
  dst_rowsize = (((crop_width * bps * spp) + 7) / 8);

  for (row = first_row; row <= last_row; row++){
    src_offset = row * src_rowsize;
    dst_offset = (row - first_row) * dst_rowsize;
    src = read_buff + src_offset;
    dst = crop_buff + dst_offset;

    switch (shift_width){
      case 0: if (extractContigSamplesBytes (src, dst, img_width, sample,
                                             spp, bps, count, first_col,
                                             last_col + 1)){
         TIFFError("extractSeparateRegion",
                          "Unable to extract row %d", row);
         return (1);
         }
       break;
      case 1: if (bps == 1){
                if (extractContigSamplesShifted8bits (src, dst, img_width,
                                                      sample, spp, bps, count,
                                                      first_col, last_col + 1,
                                                      prev_trailing_bits)){
    TIFFError("extractSeparateRegion",
                            "Unable to extract row %d", row);
    return (1);
    }
    break;
  }
              else
                if (extractContigSamplesShifted16bits (src, dst, img_width,
                                                       sample, spp, bps, count,
                                                       first_col, last_col + 1,
                                                       prev_trailing_bits)){
    TIFFError("extractSeparateRegion",
                            "Unable to extract row %d", row);
    return (1);
    }
       break;
      case 2: if (extractContigSamplesShifted24bits (src, dst, img_width,
                                                     sample, spp, bps, count,
                                                     first_col, last_col + 1,
                                                     prev_trailing_bits)){
  TIFFError("extractSeparateRegion",
                          "Unable to extract row %d", row);
  return (1);
  }
       break;
      case 3:
      case 4:
      case 5: if (extractContigSamplesShifted32bits (src, dst, img_width,
                                                     sample, spp, bps, count,
                                                     first_col, last_col + 1,
                                                     prev_trailing_bits)){
  TIFFError("extractSeparateRegion",
                          "Unable to extract row %d", row);
  return (1);
  }
       break;
      default: TIFFError("extractSeparateRegion", "Unsupported bit depth %d", bps);
        return (1);
      }
    }

  return (0);
  }

static int
extractImageSection(struct image_data *image, struct pageseg *section,
                    unsigned char *src_buff, unsigned char *sect_buff){
  unsigned char bytebuff1, bytebuff2;
#ifdef DEVELMODE

#endif

  uint32 img_width, img_rowsize;
#ifdef DEVELMODE
  uint32 img_length;
#endif
  uint32 j, shift1, shift2, trailing_bits;
  uint32 row, first_row, last_row, first_col, last_col;
  uint32 src_offset, dst_offset, row_offset, col_offset;
  uint32 offset1, offset2, full_bytes;
  uint32 sect_width;
#ifdef DEVELMODE
  uint32 sect_length;
#endif
  uint16 bps, spp;

#ifdef DEVELMODE
  int k;
  unsigned char bitset;
  static char *bitarray = NULL;
#endif

  img_width = image->width;
#ifdef DEVELMODE
  img_length = image->length;
#endif
  bps = image->bps;
  spp = image->spp;

#ifdef DEVELMODE


#endif
  src_offset = 0;
  dst_offset = 0;

#ifdef DEVELMODE
  if (bitarray == NULL){
    if ((bitarray = (char *)malloc(img_width)) == NULL){
      TIFFError ("", "DEBUG: Unable to allocate debugging bitarray");
      return (-1);
      }
    }
#endif


  first_row = section->y1;
  last_row = section->y2;
  first_col = section->x1;
  last_col = section->x2;

  sect_width = last_col - first_col + 1;
#ifdef DEVELMODE
  sect_length = last_row - first_row + 1;
#endif
  img_rowsize = ((img_width * bps + 7) / 8) * spp;
  full_bytes = (sect_width * spp * bps) / 8;
  trailing_bits = (sect_width * bps) % 8;

#ifdef DEVELMODE
    TIFFError ("", "First row: %d, last row: %d, First col: %d, last col: %d\n",
           first_row, last_row, first_col, last_col);
    TIFFError ("", "Image width: %d, Image length: %d, bps: %d, spp: %d\n",
    img_width, img_length, bps, spp);
    TIFFError ("", "Sect  width: %d,  Sect length: %d, full bytes: %d trailing bits %d\n",
           sect_width, sect_length, full_bytes, trailing_bits);
#endif

  if ((bps % 8) == 0){
    col_offset = first_col * spp * bps / 8;
    for (row = first_row; row <= last_row; row++){

      row_offset = row * img_rowsize;
      src_offset = row_offset + col_offset;

#ifdef DEVELMODE
        TIFFError ("", "Src offset: %8d, Dst offset: %8d", src_offset, dst_offset);
#endif
      _TIFFmemcpy (sect_buff + dst_offset, src_buff + src_offset, full_bytes);
      dst_offset += full_bytes;
      }
    }
  else{
    shift1 = spp * ((first_col * bps) % 8);
    shift2 = spp * ((last_col * bps) % 8);
    for (row = first_row; row <= last_row; row++){

      row_offset = row * img_rowsize;
      offset1 = row_offset + (first_col * bps / 8);
      offset2 = row_offset + (last_col * bps / 8);

#ifdef DEVELMODE
      for (j = 0, k = 7; j < 8; j++, k--){
        bitset = *(src_buff + offset1) & (((unsigned char)1 << k)) ? 1 : 0;
        sprintf(&bitarray[j], (bitset) ? "1" : "0");
        }
      sprintf(&bitarray[8], " ");
      sprintf(&bitarray[9], " ");
      for (j = 10, k = 7; j < 18; j++, k--){
        bitset = *(src_buff + offset2) & (((unsigned char)1 << k)) ? 1 : 0;
        sprintf(&bitarray[j], (bitset) ? "1" : "0");
        }
      bitarray[18] = '\0';
      TIFFError ("", "Row: %3d Offset1: %d,  Shift1: %d,    Offset2: %d,  Shift2:  %d\n",
                 row, offset1, shift1, offset2, shift2);
#endif

      bytebuff1 = bytebuff2 = 0;
      if (shift1 == 0){
 _TIFFmemcpy (sect_buff + dst_offset, src_buff + offset1, full_bytes);

#ifdef DEVELMODE
 TIFFError ("", "        Alligned data src offset1: %8d, Dst offset: %8d\n", offset1, dst_offset);
 sprintf(&bitarray[18], "\n");
 sprintf(&bitarray[19], "\t");
        for (j = 20, k = 7; j < 28; j++, k--){
          bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;
          sprintf(&bitarray[j], (bitset) ? "1" : "0");
          }
        bitarray[28] = ' ';
        bitarray[29] = ' ';
#endif
        dst_offset += full_bytes;

        if (trailing_bits != 0){
   bytebuff2 = src_buff[offset2] & ((unsigned char)255 << (7 - shift2));
          sect_buff[dst_offset] = bytebuff2;
#ifdef DEVELMODE
   TIFFError ("", "        Trailing bits src offset:  %8d, Dst offset: %8d\n",
                              offset2, dst_offset);
          for (j = 30, k = 7; j < 38; j++, k--){
            bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;
            sprintf(&bitarray[j], (bitset) ? "1" : "0");
            }
          bitarray[38] = '\0';
          TIFFError ("", "\tFirst and last bytes before and after masking:\n\t%s\n\n", bitarray);
#endif
          dst_offset++;
          }
        }
      else{
#ifdef DEVELMODE
   TIFFError ("", "        Unalligned data src offset: %8d, Dst offset: %8d\n", offset1 , dst_offset);
#endif
        for (j = 0; j <= full_bytes; j++){
   bytebuff1 = src_buff[offset1 + j] & ((unsigned char)255 >> shift1);
   bytebuff2 = src_buff[offset1 + j + 1] & ((unsigned char)255 << (7 - shift1));
          sect_buff[dst_offset + j] = (bytebuff1 << shift1) | (bytebuff2 >> (8 - shift1));
          }
#ifdef DEVELMODE
 sprintf(&bitarray[18], "\n");
 sprintf(&bitarray[19], "\t");
        for (j = 20, k = 7; j < 28; j++, k--){
          bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;
          sprintf(&bitarray[j], (bitset) ? "1" : "0");
          }
        bitarray[28] = ' ';
        bitarray[29] = ' ';
#endif
        dst_offset += full_bytes;

        if (trailing_bits != 0){
#ifdef DEVELMODE
     TIFFError ("", "        Trailing bits   src offset: %8d, Dst offset: %8d\n", offset1 + full_bytes, dst_offset);
#endif
   if (shift2 > shift1){
     bytebuff1 = src_buff[offset1 + full_bytes] & ((unsigned char)255 << (7 - shift2));
            bytebuff2 = bytebuff1 & ((unsigned char)255 << shift1);
            sect_buff[dst_offset] = bytebuff2;
#ifdef DEVELMODE
     TIFFError ("", "        Shift2 > Shift1\n");
#endif
            }
          else{
     if (shift2 < shift1){
              bytebuff2 = ((unsigned char)255 << (shift1 - shift2 - 1));
       sect_buff[dst_offset] &= bytebuff2;
#ifdef DEVELMODE
       TIFFError ("", "        Shift2 < Shift1\n");
#endif
              }
#ifdef DEVELMODE
            else
       TIFFError ("", "        Shift2 == Shift1\n");
#endif
            }
   }
#ifdef DEVELMODE
   sprintf(&bitarray[28], " ");
   sprintf(&bitarray[29], " ");
          for (j = 30, k = 7; j < 38; j++, k--){
            bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;
            sprintf(&bitarray[j], (bitset) ? "1" : "0");
            }
          bitarray[38] = '\0';
          TIFFError ("", "\tFirst and last bytes before and after masking:\n\t%s\n\n", bitarray);
#endif
        dst_offset++;
        }
      }
    }

  return (0);
  }

static int
writeSelections(TIFF *in, TIFF **out, struct crop_mask *crop,
                struct image_data *image, struct dump_opts *dump,
                struct buffinfo seg_buffs[], char *mp, char *filename,
                unsigned int *page, unsigned int total_pages){
  int i, page_count;
  int autoindex = 0;
  unsigned char *crop_buff = NULL;


  switch (crop->exp_mode){
    case ONE_FILE_COMPOSITE:
         autoindex = 0;
         crop_buff = seg_buffs[0].buffer;
         if (update_output_file (out, mp, autoindex, filename, page))
           return (1);
         page_count = total_pages;
         if (writeCroppedImage(in, *out, image, dump,
                               crop->combined_width,
                               crop->combined_length,
                               crop_buff, *page, total_pages)){
             TIFFError("writeRegions", "Unable to write new image");
             return (-1);
             }
  break;
    case ONE_FILE_SEPARATED:
         autoindex = 0;
         if (update_output_file (out, mp, autoindex, filename, page))
           return (1);
         page_count = crop->selections * total_pages;
         for (i = 0; i < crop->selections; i++){
           crop_buff = seg_buffs[i].buffer;
           if (writeCroppedImage(in, *out, image, dump,
                                 crop->regionlist[i].width,
                                 crop->regionlist[i].length,
                                 crop_buff, *page, page_count)){
             TIFFError("writeRegions", "Unable to write new image");
             return (-1);
             }
    }
         break;
    case FILE_PER_IMAGE_COMPOSITE:
         autoindex = 1;
         if (update_output_file (out, mp, autoindex, filename, page))
           return (1);

         crop_buff = seg_buffs[0].buffer;
         if (writeCroppedImage(in, *out, image, dump,
                               crop->combined_width,
                               crop->combined_length,
                               crop_buff, *page, total_pages)){
           TIFFError("writeRegions", "Unable to write new image");
           return (-1);
           }
         break;
    case FILE_PER_IMAGE_SEPARATED:
         autoindex = 1;
         page_count = crop->selections;
         if (update_output_file (out, mp, autoindex, filename, page))
           return (1);

         for (i = 0; i < crop->selections; i++){
           crop_buff = seg_buffs[i].buffer;

           if (writeCroppedImage(in, *out, image, dump,
                                 crop->regionlist[i].width,
                                 crop->regionlist[i].length,
                                 crop_buff, *page, page_count)){
             TIFFError("writeRegions", "Unable to write new image");
             return (-1);
             }
           }
         break;
    case FILE_PER_SELECTION:
         autoindex = 1;
  page_count = 1;
         for (i = 0; i < crop->selections; i++){
           if (update_output_file (out, mp, autoindex, filename, page))
             return (1);

           crop_buff = seg_buffs[i].buffer;

           if (writeCroppedImage(in, *out, image, dump,
                                 crop->regionlist[i].width,
                                 crop->regionlist[i].length,
                                 crop_buff, *page, page_count)){
             TIFFError("writeRegions", "Unable to write new image");
             return (-1);
             }
           }
  break;
    default: return (1);
    }

  return (0);
  }

static int
writeImageSections(TIFF *in, TIFF *out, struct image_data *image,
     struct pagedef *page, struct pageseg *sections,
     struct dump_opts * dump, unsigned char *src_buff,
                   unsigned char **sect_buff_ptr){
  double hres, vres;
  uint32 i, k, width, length, sectsize;
  unsigned char *sect_buff = *sect_buff_ptr;

  hres = page->hres;
  vres = page->vres;

  k = page->cols * page->rows;
  if ((k < 1) || (k > MAX_SECTIONS)){
   TIFFError("writeImageSections",
      "%d Rows and Columns exceed maximum sections\nIncrease resolution or reduce sections", k);
   return (-1);
   }

  for (i = 0; i < k; i++){
    width = sections[i].x2 - sections[i].x1 + 1;
    length = sections[i].y2 - sections[i].y1 + 1;
    sectsize = (uint32)
     ceil((width * image->bps + 7) / (double)8) * image->spp * length;

    if (createImageSection(sectsize, sect_buff_ptr)){
      TIFFError("writeImageSections", "Unable to allocate section buffer");
      exit (-1);
      }
    sect_buff = *sect_buff_ptr;

    if (extractImageSection (image, &sections[i], src_buff, sect_buff)){
      TIFFError("writeImageSections", "Unable to extract image sections");
      exit (-1);
      }


    if (writeSingleSection(in, out, image, dump, width, length, hres, vres, sect_buff)){
      TIFFError("writeImageSections", "Unable to write image section");
      exit (-1);
      }
    }

  return (0);
  }







static int
writeSingleSection(TIFF *in, TIFF *out, struct image_data *image,
                   struct dump_opts *dump, uint32 width, uint32 length,
                   double hres, double vres,
                   unsigned char *sect_buff){
  uint16 bps, spp;
  uint16 input_compression, input_photometric;
  uint16 input_planar;
  struct cpTag* p;




  input_compression = image->compression;
  input_photometric = image->photometric;

  spp = image->spp;
  bps = image->bps;
  TIFFSetField(out, TIFFTAG_IMAGEWIDTH, width);
  TIFFSetField(out, TIFFTAG_IMAGELENGTH, length);
  TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, bps);
  TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, spp);

#ifdef DEBUG2
  TIFFError("writeSingleSection", "Input compression: %s",
     (input_compression == COMPRESSION_OJPEG) ? "Old Jpeg" :
     ((input_compression == COMPRESSION_JPEG) ? "New Jpeg" : "Non Jpeg"));
#endif





  if (compression != (uint16)-1)
    TIFFSetField(out, TIFFTAG_COMPRESSION, compression);
  else{
    if (input_compression == COMPRESSION_OJPEG){
      compression = COMPRESSION_JPEG;
      jpegcolormode = JPEGCOLORMODE_RAW;
      TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);
      }
    else
      CopyField(TIFFTAG_COMPRESSION, compression);
    }

  if (compression == COMPRESSION_JPEG){
    if ((input_photometric == PHOTOMETRIC_PALETTE) ||
        (input_photometric == PHOTOMETRIC_MASK)){
      TIFFError ("writeSingleSection",
                 "JPEG compression cannot be used with %s image data",
   (input_photometric == PHOTOMETRIC_PALETTE) ?
                 "palette" : "mask");
      return (-1);
      }
    if ((input_photometric == PHOTOMETRIC_RGB) &&
 (jpegcolormode == JPEGCOLORMODE_RGB))
      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);
    else
 TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);
    }
  else{
    if (compression == COMPRESSION_SGILOG || compression == COMPRESSION_SGILOG24)
      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, spp == 1 ?
   PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);
    else
      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, image->photometric);
    }

#ifdef DEBUG2
  TIFFError("writeSingleSection", "Input photometric: %s",
     (input_photometric == PHOTOMETRIC_RGB) ? "RGB" :
     ((input_photometric == PHOTOMETRIC_YCBCR) ? "YCbCr" : "Not RGB or YCbCr"));
#endif

  if (((input_photometric == PHOTOMETRIC_LOGL) ||
       (input_photometric == PHOTOMETRIC_LOGLUV)) &&
      ((compression != COMPRESSION_SGILOG) &&
       (compression != COMPRESSION_SGILOG24))){
    TIFFError("writeSingleSection",
              "LogL and LogLuv source data require SGI_LOG or SGI_LOG24 compression");
    return (-1);
    }

  if (fillorder != 0)
    TIFFSetField(out, TIFFTAG_FILLORDER, fillorder);
  else
    CopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT);
# 7143 "originals/113a.c"
  TIFFSetField(out, TIFFTAG_ORIENTATION, image->orientation);






  if (outtiled == -1)
    outtiled = TIFFIsTiled(in);
  if (outtiled){






    if (tilewidth == (uint32) 0)
      TIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth);
    if (tilelength == (uint32) 0)
      TIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength);

    if (tilewidth == 0 || tilelength == 0)
      TIFFDefaultTileSize(out, &tilewidth, &tilelength);
    TIFFDefaultTileSize(out, &tilewidth, &tilelength);
    TIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth);
    TIFFSetField(out, TIFFTAG_TILELENGTH, tilelength);
    } else{





 if (rowsperstrip == (uint32) 0){
   if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip))
     rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);
          if (compression != COMPRESSION_JPEG){
       if (rowsperstrip > length)
       rowsperstrip = length;
     }
   }
 else
          if (rowsperstrip == (uint32) -1)
     rowsperstrip = length;
 TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);
 }

  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &input_planar);
  if (config != (uint16) -1)
    TIFFSetField(out, TIFFTAG_PLANARCONFIG, config);
  else
    CopyField(TIFFTAG_PLANARCONFIG, config);
  if (spp <= 4)
    CopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT);
  CopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT);


  switch (compression){



    case COMPRESSION_JPEG:
         if (((bps % 8) == 0) || ((bps % 12) == 0)){
           TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);
    TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);
           }
         else{
    TIFFError("writeSingleSection",
                     "JPEG compression requires 8 or 12 bits per sample");
           return (-1);
           }
  break;
   case COMPRESSION_LZW:
   case COMPRESSION_ADOBE_DEFLATE:
   case COMPRESSION_DEFLATE:
 if (predictor != (uint16)-1)
          TIFFSetField(out, TIFFTAG_PREDICTOR, predictor);
 else
   CopyField(TIFFTAG_PREDICTOR, predictor);
 break;
   case COMPRESSION_CCITTFAX3:
   case COMPRESSION_CCITTFAX4:
 if (compression == COMPRESSION_CCITTFAX3){
          if (g3opts != (uint32) -1)
     TIFFSetField(out, TIFFTAG_GROUP3OPTIONS, g3opts);
   else
     CopyField(TIFFTAG_GROUP3OPTIONS, g3opts);
 } else{
     CopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG);
        }
        CopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG);
        CopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG);
        CopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG);
        CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);
        CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);
        CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);
 break;
   }{ uint32 len32;
     void** data;
     if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data))
       TIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data);
   }{ uint16 ninks;
     const char* inknames;
     if (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)){
       TIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);
       if (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)){
  int inknameslen = strlen(inknames) + 1;
  const char* cp = inknames;
  while (ninks > 1){
    cp = strchr(cp, '\0');
    if (cp){
      cp++;
      inknameslen += (strlen(cp) + 1);
    }
    ninks--;
         }
  TIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames);
       }
     }
   }{
   unsigned short pg0, pg1;
   if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)){
     if (pageNum < 0)
 TIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);
     else
 TIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);
     }
   }

  for (p = tags; p < &tags[NTAGS]; p++)
  CopyTag(p->tag, p->count, p->type);


  TIFFSetField(out, TIFFTAG_XRESOLUTION, (float)hres);
  TIFFSetField(out, TIFFTAG_YRESOLUTION, (float)vres);


  if (outtiled){
    if (config == PLANARCONFIG_CONTIG)
      writeBufferToContigTiles (out, sect_buff, length, width, spp, dump);
    else
      writeBufferToSeparateTiles (out, sect_buff, length, width, spp, dump);
    }
  else{
    if (config == PLANARCONFIG_CONTIG)
      writeBufferToContigStrips (out, sect_buff, length);
    else
      writeBufferToSeparateStrips(out, sect_buff, length, width, spp, dump);
    }

  if (!TIFFWriteDirectory(out)){
    TIFFClose(out);
    return (-1);
    }

  return (0);
  }



static int
createImageSection(uint32 sectsize, unsigned char **sect_buff_ptr){
  unsigned char *sect_buff = NULL;
  unsigned char *new_buff = NULL;
  static uint32 prev_sectsize = 0;

  sect_buff = *sect_buff_ptr;

  if (!sect_buff){
    sect_buff = (unsigned char *)_TIFFmalloc(sectsize);
    *sect_buff_ptr = sect_buff;
    _TIFFmemset(sect_buff, 0, sectsize);
    }
  else{
    if (prev_sectsize < sectsize){
      new_buff = _TIFFrealloc(sect_buff, sectsize);
      if (!new_buff){
 free (sect_buff);
        sect_buff = (unsigned char *)_TIFFmalloc(sectsize);
        }
      else
        sect_buff = new_buff;

      _TIFFmemset(sect_buff, 0, sectsize);
      }
    }

  if (!sect_buff){
    TIFFError("createImageSection", "Unable to allocate/reallocate section buffer");
    return (-1);
    }
  prev_sectsize = sectsize;
  *sect_buff_ptr = sect_buff;

  return (0);
  }



static int
processCropSelections(struct image_data *image, struct crop_mask *crop,
                      unsigned char **read_buff_ptr, struct buffinfo seg_buffs[]){
  int i;
  uint32 width, length, total_width, total_length;
  tsize_t cropsize;
  unsigned char *crop_buff = NULL;
  unsigned char *read_buff = NULL;
  unsigned char *next_buff = NULL;
  tsize_t prev_cropsize = 0;

  read_buff = *read_buff_ptr;

  if (crop->img_mode == COMPOSITE_IMAGES){
    cropsize = crop->bufftotal;
    crop_buff = seg_buffs[0].buffer;
    if (!crop_buff)
      crop_buff = (unsigned char *)_TIFFmalloc(cropsize);
    else{
      prev_cropsize = seg_buffs[0].size;
      if (prev_cropsize < cropsize){
        next_buff = _TIFFrealloc(crop_buff, cropsize);
        if (! next_buff){
          _TIFFfree (crop_buff);
          crop_buff = (unsigned char *)_TIFFmalloc(cropsize);
          }
        else
          crop_buff = next_buff;
        }
      }

    if (!crop_buff){
      TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");
      return (-1);
      }

    _TIFFmemset(crop_buff, 0, cropsize);
    seg_buffs[0].buffer = crop_buff;
    seg_buffs[0].size = cropsize;


    if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)
      return (1);

    if (crop->crop_mode & CROP_INVERT){
      switch (crop->photometric){

        case PHOTOMETRIC_MINISWHITE:
        case PHOTOMETRIC_MINISBLACK:
      image->photometric = crop->photometric;
      break;
        case INVERT_DATA_ONLY:
        case INVERT_DATA_AND_TAG:
             if (invertImage(image->photometric, image->spp, image->bps,
                             crop->combined_width, crop->combined_length, crop_buff)){
               TIFFError("processCropSelections",
                         "Failed to invert colorspace for composite regions");
               return (-1);
               }
             if (crop->photometric == INVERT_DATA_AND_TAG){
               switch (image->photometric){
                 case PHOTOMETRIC_MINISWHITE:
                image->photometric = PHOTOMETRIC_MINISBLACK;
               break;
                 case PHOTOMETRIC_MINISBLACK:
                image->photometric = PHOTOMETRIC_MINISWHITE;
               break;
                 default:
               break;
          }
        }
             break;
        default: break;
        }
      }


    if (crop->crop_mode & CROP_MIRROR){
      if (mirrorImage(image->spp, image->bps, crop->mirror,
                      crop->combined_width, crop->combined_length, crop_buff)){
        TIFFError("processCropSelections", "Failed to mirror composite regions %s",
          (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");
        return (-1);
        }
      }

    if (crop->crop_mode & CROP_ROTATE){
      if (rotateImage(crop->rotation, image, &crop->combined_width,
                      &crop->combined_length, &crop_buff)){
        TIFFError("processCropSelections",
                  "Failed to rotate composite regions by %d degrees", crop->rotation);
        return (-1);
        }
      seg_buffs[0].buffer = crop_buff;
      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)
                            * image->spp) * crop->combined_length;
      }
    }
  else{
    total_width = total_length = 0;
    for (i = 0; i < crop->selections; i++){
      cropsize = crop->bufftotal;
      crop_buff = seg_buffs[i].buffer;
      if (!crop_buff)
        crop_buff = (unsigned char *)_TIFFmalloc(cropsize);
      else{
        prev_cropsize = seg_buffs[0].size;
        if (prev_cropsize < cropsize){
          next_buff = _TIFFrealloc(crop_buff, cropsize);
          if (! next_buff){
            _TIFFfree (crop_buff);
            crop_buff = (unsigned char *)_TIFFmalloc(cropsize);
            }
          else
            crop_buff = next_buff;
          }
        }

      if (!crop_buff){
        TIFFError("processCropSelections", "Unable to allocate/reallocate crop buffer");
        return (-1);
        }

      _TIFFmemset(crop_buff, 0, cropsize);
      seg_buffs[i].buffer = crop_buff;
      seg_buffs[i].size = cropsize;

      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i)){
 TIFFError("processCropSelections", "Unable to extract cropped region %d from image", i);
        return (-1);
        }

      width = crop->regionlist[i].width;
      length = crop->regionlist[i].length;

      if (crop->crop_mode & CROP_INVERT){
        switch (crop->photometric){

          case PHOTOMETRIC_MINISWHITE:
          case PHOTOMETRIC_MINISBLACK:
        image->photometric = crop->photometric;
        break;
          case INVERT_DATA_ONLY:
          case INVERT_DATA_AND_TAG:
               if (invertImage(image->photometric, image->spp, image->bps,
                               width, length, crop_buff)){
                 TIFFError("processCropSelections",
                           "Failed to invert colorspace for region");
                 return (-1);
                 }
               if (crop->photometric == INVERT_DATA_AND_TAG){
                 switch (image->photometric){
                   case PHOTOMETRIC_MINISWHITE:
                  image->photometric = PHOTOMETRIC_MINISBLACK;
                 break;
                   case PHOTOMETRIC_MINISBLACK:
                  image->photometric = PHOTOMETRIC_MINISWHITE;
                 break;
                   default:
                 break;
            }
          }
               break;
          default: break;
          }
        }

      if (crop->crop_mode & CROP_MIRROR){
        if (mirrorImage(image->spp, image->bps, crop->mirror,
                        width, length, crop_buff)){
          TIFFError("processCropSelections", "Failed to mirror crop region %s",
            (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");
          return (-1);
          }
        }

      if (crop->crop_mode & CROP_ROTATE){
 if (rotateImage(crop->rotation, image, &crop->regionlist[i].width,
   &crop->regionlist[i].length, &crop_buff)){
          TIFFError("processCropSelections",
                    "Failed to rotate crop region by %d degrees", crop->rotation);
          return (-1);
          }
        total_width += crop->regionlist[i].width;
        total_length += crop->regionlist[i].length;
        crop->combined_width = total_width;
        crop->combined_length = total_length;
        seg_buffs[i].buffer = crop_buff;
        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)
                               * image->spp) * crop->regionlist[i].length;
        }
      }
    }
  return (0);
  }
# 7592 "originals/113a.c"
static int
createCroppedImage(struct image_data *image, struct crop_mask *crop,
                   unsigned char **read_buff_ptr, unsigned char **crop_buff_ptr){
  tsize_t cropsize;
  unsigned char *read_buff = NULL;
  unsigned char *crop_buff = NULL;
  unsigned char *new_buff = NULL;
  static tsize_t prev_cropsize = 0;

  read_buff = *read_buff_ptr;


  crop_buff = read_buff;
  *crop_buff_ptr = read_buff;
  crop->combined_width = image->width;
  crop->combined_length = image->length;

  cropsize = crop->bufftotal;
  crop_buff = *crop_buff_ptr;
  if (!crop_buff){
    crop_buff = (unsigned char *)_TIFFmalloc(cropsize);
    *crop_buff_ptr = crop_buff;
    _TIFFmemset(crop_buff, 0, cropsize);
    prev_cropsize = cropsize;
    }
  else{
    if (prev_cropsize < cropsize){
      new_buff = _TIFFrealloc(crop_buff, cropsize);
      if (!new_buff){
 free (crop_buff);
        crop_buff = (unsigned char *)_TIFFmalloc(cropsize);
        }
      else
        crop_buff = new_buff;
      _TIFFmemset(crop_buff, 0, cropsize);
      }
    }

  if (!crop_buff){
    TIFFError("createCroppedImage", "Unable to allocate/reallocate crop buffer");
    return (-1);
    }
  *crop_buff_ptr = crop_buff;

  if (crop->crop_mode & CROP_INVERT){
    switch (crop->photometric){

      case PHOTOMETRIC_MINISWHITE:
      case PHOTOMETRIC_MINISBLACK:
    image->photometric = crop->photometric;
    break;
      case INVERT_DATA_ONLY:
      case INVERT_DATA_AND_TAG:
           if (invertImage(image->photometric, image->spp, image->bps,
                           crop->combined_width, crop->combined_length, crop_buff)){
             TIFFError("createCroppedImage",
                       "Failed to invert colorspace for image or cropped selection");
             return (-1);
             }
           if (crop->photometric == INVERT_DATA_AND_TAG){
             switch (image->photometric){
               case PHOTOMETRIC_MINISWHITE:
              image->photometric = PHOTOMETRIC_MINISBLACK;
             break;
               case PHOTOMETRIC_MINISBLACK:
              image->photometric = PHOTOMETRIC_MINISWHITE;
             break;
               default:
             break;
        }
      }
           break;
      default: break;
      }
    }

  if (crop->crop_mode & CROP_MIRROR){
    if (mirrorImage(image->spp, image->bps, crop->mirror,
                    crop->combined_width, crop->combined_length, crop_buff)){
      TIFFError("createCroppedImage", "Failed to mirror image or cropped selection %s",
        (crop->rotation == MIRROR_HORIZ) ? "horizontally" : "vertically");
      return (-1);
      }
    }

  if (crop->crop_mode & CROP_ROTATE){
    if (rotateImage(crop->rotation, image, &crop->combined_width,
                    &crop->combined_length, crop_buff_ptr)){
      TIFFError("createCroppedImage",
                "Failed to rotate image or cropped selection by %d degrees", crop->rotation);
      return (-1);
      }
    }

  if (crop_buff == read_buff)
    *read_buff_ptr = NULL;

  return (0);
  }
# 7719 "originals/113a.c"
static int
writeCroppedImage(TIFF *in, TIFF *out, struct image_data *image,
                  struct dump_opts *dump, uint32 width, uint32 length,
                  unsigned char *crop_buff, int pagenum, int total_pages){
  uint16 bps, spp;
  uint16 input_compression, input_photometric;
  uint16 input_planar;
  struct cpTag* p;

  input_compression = image->compression;
  input_photometric = image->photometric;
  spp = image->spp;
  bps = image->bps;

  TIFFSetField(out, TIFFTAG_IMAGEWIDTH, width);
  TIFFSetField(out, TIFFTAG_IMAGELENGTH, length);
  TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, bps);
  TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, spp);

#ifdef DEBUG2
  TIFFError("writeCroppedImage", "Input compression: %s",
     (input_compression == COMPRESSION_OJPEG) ? "Old Jpeg" :
     ((input_compression == COMPRESSION_JPEG) ? "New Jpeg" : "Non Jpeg"));
#endif

  if (compression != (uint16)-1)
    TIFFSetField(out, TIFFTAG_COMPRESSION, compression);
  else{
    if (input_compression == COMPRESSION_OJPEG){
      compression = COMPRESSION_JPEG;
      jpegcolormode = JPEGCOLORMODE_RAW;
      TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);
      }
    else
      CopyField(TIFFTAG_COMPRESSION, compression);
    }

  if (compression == COMPRESSION_JPEG){
    if ((input_photometric == PHOTOMETRIC_PALETTE) ||
        (input_photometric == PHOTOMETRIC_MASK)){
      TIFFError ("writeCroppedImage",
                 "JPEG compression cannot be used with %s image data",
               (input_photometric == PHOTOMETRIC_PALETTE) ?
                 "palette" : "mask");
      return (-1);
      }
    if ((input_photometric == PHOTOMETRIC_RGB) &&
 (jpegcolormode == JPEGCOLORMODE_RGB))
      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);
    else
 TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);
    }
  else{
    if (compression == COMPRESSION_SGILOG || compression == COMPRESSION_SGILOG24){
      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, spp == 1 ?
   PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);
      }
    else{
      if (input_compression == COMPRESSION_SGILOG ||
          input_compression == COMPRESSION_SGILOG24){
        TIFFSetField(out, TIFFTAG_PHOTOMETRIC, spp == 1 ?
     PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);
        }
      else
        TIFFSetField(out, TIFFTAG_PHOTOMETRIC, image->photometric);
      }
    }

  if (((input_photometric == PHOTOMETRIC_LOGL) ||
       (input_photometric == PHOTOMETRIC_LOGLUV)) &&
      ((compression != COMPRESSION_SGILOG) &&
       (compression != COMPRESSION_SGILOG24))){
    TIFFError("writeCroppedImage",
              "LogL and LogLuv source data require SGI_LOG or SGI_LOG24 compression");
    return (-1);
    }

  if (fillorder != 0)
    TIFFSetField(out, TIFFTAG_FILLORDER, fillorder);
  else
    CopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT);
# 7818 "originals/113a.c"
  TIFFSetField(out, TIFFTAG_ORIENTATION, image->orientation);






  if (outtiled == -1)
    outtiled = TIFFIsTiled(in);
  if (outtiled){






    if (tilewidth == (uint32) 0)
      TIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth);
    if (tilelength == (uint32) 0)
      TIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength);

    if (tilewidth == 0 || tilelength == 0)
      TIFFDefaultTileSize(out, &tilewidth, &tilelength);
    TIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth);
    TIFFSetField(out, TIFFTAG_TILELENGTH, tilelength);
    } else{





 if (rowsperstrip == (uint32) 0){
   if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip))
     rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);
          if (compression != COMPRESSION_JPEG){
       if (rowsperstrip > length)
       rowsperstrip = length;
     }
   }
 else
          if (rowsperstrip == (uint32) -1)
     rowsperstrip = length;
 TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);
 }

  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &input_planar);
  if (config != (uint16) -1)
    TIFFSetField(out, TIFFTAG_PLANARCONFIG, config);
  else
    CopyField(TIFFTAG_PLANARCONFIG, config);
  if (spp <= 4)
    CopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT);
  CopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT);


  switch (compression){
    case COMPRESSION_JPEG:
         if (((bps % 8) == 0) || ((bps % 12) == 0)){
           TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);
    TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);
           }
         else{
    TIFFError("writeCroppedImage",
                     "JPEG compression requires 8 or 12 bits per sample");
           return (-1);
           }
  break;
   case COMPRESSION_LZW:
   case COMPRESSION_ADOBE_DEFLATE:
   case COMPRESSION_DEFLATE:
 if (predictor != (uint16)-1)
          TIFFSetField(out, TIFFTAG_PREDICTOR, predictor);
 else
   CopyField(TIFFTAG_PREDICTOR, predictor);
 break;
   case COMPRESSION_CCITTFAX3:
   case COMPRESSION_CCITTFAX4:
        if (bps != 1){
   TIFFError("writeCroppedImage",
            "Group 3/4 compression is not usable with bps > 1");
          return (-1);
   }
 if (compression == COMPRESSION_CCITTFAX3){
          if (g3opts != (uint32) -1)
     TIFFSetField(out, TIFFTAG_GROUP3OPTIONS, g3opts);
   else
     CopyField(TIFFTAG_GROUP3OPTIONS, g3opts);
 } else{
     CopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG);
        }
        CopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG);
        CopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG);
        CopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG);
        CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);
        CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);
        CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);
        break;
    case COMPRESSION_NONE:
         break;
    default: break;
   }{ uint32 len32;
     void** data;
     if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data))
       TIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data);
   }{ uint16 ninks;
     const char* inknames;
     if (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)){
       TIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);
       if (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)){
  int inknameslen = strlen(inknames) + 1;
  const char* cp = inknames;
  while (ninks > 1){
    cp = strchr(cp, '\0');
    if (cp){
      cp++;
      inknameslen += (strlen(cp) + 1);
    }
    ninks--;
         }
  TIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames);
       }
     }
   }{
   unsigned short pg0, pg1;
   if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)){
     TIFFSetField(out, TIFFTAG_PAGENUMBER, pagenum, total_pages);
     }
   }

  for (p = tags; p < &tags[NTAGS]; p++)
  CopyTag(p->tag, p->count, p->type);


  if (outtiled){
    if (config == PLANARCONFIG_CONTIG){
      if (writeBufferToContigTiles (out, crop_buff, length, width, spp, dump))
        TIFFError("","Unable to write contiguous tile data for page %d", pagenum);
      }
    else{
      if (writeBufferToSeparateTiles (out, crop_buff, length, width, spp, dump))
        TIFFError("","Unable to write separate tile data for page %d", pagenum);
      }
    }
  else{
    if (config == PLANARCONFIG_CONTIG){
      if (writeBufferToContigStrips (out, crop_buff, length))
        TIFFError("","Unable to write contiguous strip data for page %d", pagenum);
      }
    else{
      if (writeBufferToSeparateStrips(out, crop_buff, length, width, spp, dump))
        TIFFError("","Unable to write separate strip data for page %d", pagenum);
      }
    }

  if (!TIFFWriteDirectory(out)){
    TIFFError("","Failed to write IFD for page number %d", pagenum);
    TIFFClose(out);
    return (-1);
    }

  return (0);
  }

static int
rotateContigSamples8bits(uint16 rotation, uint16 spp, uint16 bps, uint32 width,
                         uint32 length, uint32 col, uint8 *src, uint8 *dst){
  int ready_bits = 0;
  uint32 src_byte = 0, src_bit = 0;
  uint32 row, rowsize = 0, bit_offset = 0;
  uint8 matchbits = 0, maskbits = 0;
  uint8 buff1 = 0, buff2 = 0;
  uint8 *next;
  tsample_t sample;

  if ((src == NULL) || (dst == NULL)){
    TIFFError("rotateContigSamples8bits","Invalid src or destination buffer");
    return (1);
    }

  rowsize = ((bps * spp * width) + 7) / 8;
  ready_bits = 0;
  maskbits = (uint8)-1 >> ( 8 - bps);
  buff1 = buff2 = 0;

  for (row = 0; row < length ; row++){
    bit_offset = col * bps * spp;
    for (sample = 0; sample < spp; sample++){
      if (sample == 0){
        src_byte = bit_offset / 8;
        src_bit = bit_offset % 8;
        }
      else{
        src_byte = (bit_offset + (sample * bps)) / 8;
        src_bit = (bit_offset + (sample * bps)) % 8;
        }

      switch (rotation){
        case 90: next = src + src_byte - (row * rowsize);
                  break;
        case 270: next = src + src_byte + (row * rowsize);
           break;
 default: TIFFError("rotateContigSamples8bits", "Invalid rotation %d", rotation);
                  return (1);
        }
      matchbits = maskbits << (8 - src_bit - bps);
      buff1 = ((*next) & matchbits) << (src_bit);


      if (ready_bits >= 8){
        *dst++ = buff2;
        buff2 = buff1;
        ready_bits -= 8;
        }
      else{
        buff2 = (buff2 | (buff1 >> ready_bits));
        }
      ready_bits += bps;
      }
    }

  if (ready_bits > 0){
    buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));
    *dst++ = buff1;
    }

  return (0);
  }


static int
rotateContigSamples16bits(uint16 rotation, uint16 spp, uint16 bps, uint32 width,
                         uint32 length, uint32 col, uint8 *src, uint8 *dst){
  int ready_bits = 0;
  uint32 row, rowsize, bit_offset;
  uint32 src_byte = 0, src_bit = 0;
  uint16 matchbits = 0, maskbits = 0;
  uint16 buff1 = 0, buff2 = 0;
  uint8 bytebuff = 0;
  uint8 *next;
  tsample_t sample;

  if ((src == NULL) || (dst == NULL)){
    TIFFError("rotateContigSamples16bits","Invalid src or destination buffer");
    return (1);
    }

  rowsize = ((bps * spp * width) + 7) / 8;
  ready_bits = 0;
  maskbits = (uint16)-1 >> (16 - bps);
  buff1 = buff2 = 0;
  for (row = 0; row < length; row++){
    bit_offset = col * bps * spp;
    for (sample = 0; sample < spp; sample++){
      if (sample == 0){
        src_byte = bit_offset / 8;
        src_bit = bit_offset % 8;
        }
      else{
        src_byte = (bit_offset + (sample * bps)) / 8;
        src_bit = (bit_offset + (sample * bps)) % 8;
        }

      switch (rotation){
        case 90: next = src + src_byte - (row * rowsize);
                  break;
        case 270: next = src + src_byte + (row * rowsize);
           break;
 default: TIFFError("rotateContigSamples8bits", "Invalid rotation %d", rotation);
                  return (1);
        }
      matchbits = maskbits << (16 - src_bit - bps);
      if (little_endian)
        buff1 = (next[0] << 8) | next[1];
      else
        buff1 = (next[1] << 8) | next[0];

      buff1 = (buff1 & matchbits) << (src_bit);


      if (ready_bits >= 8){
        bytebuff = (buff2 >> 8);
        *dst++ = bytebuff;
        ready_bits -= 8;

        buff2 = ((buff2 << 8) | (buff1 >> ready_bits));
        }
      else{
        bytebuff = 0;
        buff2 = (buff2 | (buff1 >> ready_bits));
        }
      ready_bits += bps;
      }
    }

  if (ready_bits > 0){
    bytebuff = (buff2 >> 8);
    *dst++ = bytebuff;
    }

  return (0);
  }

static int
rotateContigSamples24bits(uint16 rotation, uint16 spp, uint16 bps, uint32 width,
                          uint32 length, uint32 col, uint8 *src, uint8 *dst){
  int ready_bits = 0;
  uint32 row, rowsize, bit_offset;
  uint32 src_byte = 0, src_bit = 0;
  uint32 matchbits = 0, maskbits = 0;
  uint32 buff1 = 0, buff2 = 0;
  uint8 bytebuff1 = 0, bytebuff2 = 0;
  uint8 *next;
  tsample_t sample;


  if ((src == NULL) || (dst == NULL)){
    TIFFError("rotateContigSamples24bits","Invalid src or destination buffer");
    return (1);
    }

  rowsize = ((bps * spp * width) + 7) / 8;
  ready_bits = 0;
  maskbits = (uint32)-1 >> (32 - bps);
  buff1 = buff2 = 0;
  for (row = 0; row < length; row++){
    bit_offset = col * bps * spp;
    for (sample = 0; sample < spp; sample++){
      if (sample == 0){
        src_byte = bit_offset / 8;
        src_bit = bit_offset % 8;
        }
      else{
        src_byte = (bit_offset + (sample * bps)) / 8;
        src_bit = (bit_offset + (sample * bps)) % 8;
        }

      switch (rotation){
        case 90: next = src + src_byte - (row * rowsize);
                  break;
        case 270: next = src + src_byte + (row * rowsize);
           break;
 default: TIFFError("rotateContigSamples8bits", "Invalid rotation %d", rotation);
                  return (1);
        }
      matchbits = maskbits << (32 - src_bit - bps);
      if (little_endian)
 buff1 = (next[0] << 24) | (next[1] << 16) | (next[2] << 8) | next[3];
      else
 buff1 = (next[3] << 24) | (next[2] << 16) | (next[1] << 8) | next[0];
      buff1 = (buff1 & matchbits) << (src_bit);


      if (ready_bits >= 16){
        bytebuff1 = (buff2 >> 24);
        *dst++ = bytebuff1;
        bytebuff2 = (buff2 >> 16);
        *dst++ = bytebuff2;
        ready_bits -= 16;


        buff2 = ((buff2 << 16) | (buff1 >> ready_bits));
        }
      else{
        bytebuff1 = bytebuff2 = 0;
        buff2 = (buff2 | (buff1 >> ready_bits));
        }
      ready_bits += bps;
      }
    }


  while (ready_bits > 0){
    bytebuff1 = (buff2 >> 24);
    *dst++ = bytebuff1;

    buff2 = (buff2 << 8);
    bytebuff2 = bytebuff1;
    ready_bits -= 8;
    }

  return (0);
  }

static int
rotateContigSamples32bits(uint16 rotation, uint16 spp, uint16 bps, uint32 width,
                          uint32 length, uint32 col, uint8 *src, uint8 *dst){
  int ready_bits = 0 ;

  uint32 row, rowsize, bit_offset;
  uint32 src_byte, src_bit;
  uint32 longbuff1 = 0, longbuff2 = 0;
  uint64 maskbits = 0, matchbits = 0;
  uint64 buff1 = 0, buff2 = 0, buff3 = 0;
  uint8 bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;
  uint8 *next;
  tsample_t sample;


  if ((src == NULL) || (dst == NULL)){
    TIFFError("rotateContigSamples24bits","Invalid src or destination buffer");
    return (1);
    }
# 8275 "originals/113a.c"
  rowsize = ((bps * spp * width) + 7) / 8;
  ready_bits = 0;
  maskbits = (uint64)-1 >> (64 - bps);
  buff1 = buff2 = 0;
  for (row = 0; row < length; row++){
    bit_offset = col * bps * spp;
    for (sample = 0; sample < spp; sample++){
      if (sample == 0){
        src_byte = bit_offset / 8;
        src_bit = bit_offset % 8;
        }
      else{
        src_byte = (bit_offset + (sample * bps)) / 8;
        src_bit = (bit_offset + (sample * bps)) % 8;
        }

      switch (rotation){
        case 90: next = src + src_byte - (row * rowsize);
                  break;
        case 270: next = src + src_byte + (row * rowsize);
           break;
 default: TIFFError("rotateContigSamples8bits", "Invalid rotation %d", rotation);
                  return (1);
        }
      matchbits = maskbits << (64 - src_bit - bps);
      if (little_endian){
 longbuff1 = (next[0] << 24) | (next[1] << 16) | (next[2] << 8) | next[3];
        longbuff2 = longbuff1;
        }
      else{
 longbuff1 = (next[3] << 24) | (next[2] << 16) | (next[1] << 8) | next[0];
        longbuff2 = longbuff1;
 }

      buff3 = ((uint64)longbuff1 << 32) | longbuff2;
      buff1 = (buff3 & matchbits) << (src_bit);

      if (ready_bits < 32){
        bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;
        buff2 = (buff2 | (buff1 >> ready_bits));
        }
      else{
        bytebuff1 = (buff2 >> 56);
        *dst++ = bytebuff1;
        bytebuff2 = (buff2 >> 48);
        *dst++ = bytebuff2;
        bytebuff3 = (buff2 >> 40);
        *dst++ = bytebuff3;
        bytebuff4 = (buff2 >> 32);
        *dst++ = bytebuff4;
        ready_bits -= 32;


        buff2 = ((buff2 << 32) | (buff1 >> ready_bits));
        }
      ready_bits += bps;
      }
    }
  while (ready_bits > 0){
    bytebuff1 = (buff2 >> 56);
    *dst++ = bytebuff1;
    buff2 = (buff2 << 8);
    ready_bits -= 8;
    }

  return (0);
  }



static int
rotateImage(uint16 rotation, struct image_data *image, uint32 *img_width,
            uint32 *img_length, unsigned char **ibuff_ptr){
  int shift_width;
  uint32 bytes_per_pixel, bytes_per_sample;
  uint32 row, rowsize, src_offset, dst_offset;
  uint32 i, col, width, length;
  uint32 colsize, buffsize, col_offset, pix_offset;
  unsigned char *ibuff;
  unsigned char *src;
  unsigned char *dst;
  uint16 spp, bps;
  float res_temp;
  unsigned char *rbuff = NULL;

  width = *img_width;
  length = *img_length;
  spp = image->spp;
  bps = image->bps;

  rowsize = ((bps * spp * width) + 7) / 8;
  colsize = ((bps * spp * length) + 7) / 8;
  if ((colsize * width) > (rowsize * length))
    buffsize = (colsize + 1) * width;
  else
    buffsize = (rowsize + 1) * length;

  bytes_per_sample = (bps + 7) / 8;
  bytes_per_pixel = ((bps * spp) + 7) / 8;
  if (bytes_per_pixel < (bytes_per_sample + 1))
    shift_width = bytes_per_pixel;
  else
    shift_width = bytes_per_sample + 1;

  switch (rotation){
    case 0:
    case 360: return (0);
    case 90:
    case 180:
    case 270: break;
    default: TIFFError("rotateImage", "Invalid rotation angle %d", rotation);
              return (-1);
    }

  if (!(rbuff = (unsigned char *)_TIFFmalloc(buffsize))){
    TIFFError("rotateImage", "Unable to allocate rotation buffer of %1u bytes", buffsize);
    return (-1);
    }
  _TIFFmemset(rbuff, '\0', buffsize);

  ibuff = *ibuff_ptr;
  switch (rotation){
    case 180: if ((bps % 8) == 0){
                src = ibuff;
                pix_offset = (spp * bps) / 8;
                for (row = 0; row < length; row++){
     dst_offset = (length - row - 1) * rowsize;
                   for (col = 0; col < width; col++){
       col_offset = (width - col - 1) * pix_offset;
                     dst = rbuff + dst_offset + col_offset;

       for (i = 0; i < bytes_per_pixel; i++)
         *dst++ = *src++;
                     }
                   }
                }
       else{
                for (row = 0; row < length; row++){
    src_offset = row * rowsize;
    dst_offset = (length - row - 1) * rowsize;
    src = ibuff + src_offset;
                  dst = rbuff + dst_offset;
                  switch (shift_width){
                    case 1: if (bps == 1){
                              if (reverseSamples8bits(spp, bps, width, src, dst)){
                  _TIFFfree(rbuff);
                                return (-1);
                                }
                              break;
                              }
                            if (reverseSamples16bits(spp, bps, width, src, dst)){
                _TIFFfree(rbuff);
                              return (-1);
                              }
                             break;
                    case 2: if (reverseSamples24bits(spp, bps, width, src, dst)){
                _TIFFfree(rbuff);
                              return (-1);
                              }
                             break;
                    case 3:
                    case 4:
                    case 5: if (reverseSamples32bits(spp, bps, width, src, dst)){
                _TIFFfree(rbuff);
                              return (-1);
                              }
                             break;
                    default: TIFFError("rotateImage","Unsupported bit depth %d", bps);
               _TIFFfree(rbuff);
                             return (-1);
                    }
    }
  }
              _TIFFfree(ibuff);
              *(ibuff_ptr) = rbuff;
              break;

    case 90: if ((bps % 8) == 0){
                for (col = 0; col < width; col++){
    src_offset = ((length - 1) * rowsize) + (col * bytes_per_pixel);
                  dst_offset = col * colsize;
    src = ibuff + src_offset;
    dst = rbuff + dst_offset;
                  for (row = length; row > 0; row--){
                    for (i = 0; i < bytes_per_pixel; i++)
                      *dst++ = *(src + i);
      src -= rowsize;
                    }
    }
  }
              else{
                for (col = 0; col < width; col++){
    src_offset = (length - 1) * rowsize;
                  dst_offset = col * colsize;
    src = ibuff + src_offset;
    dst = rbuff + dst_offset;
                  switch (shift_width){
                    case 1: if (bps == 1){
                              if (rotateContigSamples8bits(rotation, spp, bps, width,
                         length, col, src, dst)){
                  _TIFFfree(rbuff);
                                return (-1);
                                }
                              break;
                              }
                            if (rotateContigSamples16bits(rotation, spp, bps, width,
                         length, col, src, dst)){
                       _TIFFfree(rbuff);
                              return (-1);
                }
              break;
                    case 2: if (rotateContigSamples24bits(rotation, spp, bps, width,
                       length, col, src, dst)){
                _TIFFfree(rbuff);
                              return (-1);
                              }
                             break;
                    case 3:
                    case 4:
                    case 5: if (rotateContigSamples32bits(rotation, spp, bps, width,
                       length, col, src, dst)){
                _TIFFfree(rbuff);
                              return (-1);
                              }
                             break;
                    default: TIFFError("rotateImage","Unsupported bit depth %d", bps);
               _TIFFfree(rbuff);
                             return (-1);
      }
    }
  }
              _TIFFfree(ibuff);
              *(ibuff_ptr) = rbuff;

              *img_width = length;
              *img_length = width;
              image->width = length;
              image->length = width;
              res_temp = image->xres;
              image->xres = image->yres;
              image->yres = res_temp;
       break;

    case 270: if ((bps % 8) == 0){
                for (col = 0; col < width; col++){
    src_offset = col * bytes_per_pixel;
                  dst_offset = (width - col - 1) * colsize;
    src = ibuff + src_offset;
    dst = rbuff + dst_offset;
                  for (row = length; row > 0; row--){
                    for (i = 0; i < bytes_per_pixel; i++)
                      *dst++ = *(src + i);
      src += rowsize;
                    }
    }
  }
              else{
                for (col = 0; col < width; col++){
    src_offset = 0;
                  dst_offset = (width - col - 1) * colsize;
    src = ibuff + src_offset;
    dst = rbuff + dst_offset;
                  switch (shift_width){
                    case 1: if (bps == 1){
                              if (rotateContigSamples8bits(rotation, spp, bps, width,
                         length, col, src, dst)){
                  _TIFFfree(rbuff);
                                return (-1);
                                }
                              break;
                              }
                            if (rotateContigSamples16bits(rotation, spp, bps, width,
                         length, col, src, dst)){
                       _TIFFfree(rbuff);
                              return (-1);
                }
              break;
                    case 2: if (rotateContigSamples24bits(rotation, spp, bps, width,
                       length, col, src, dst)){
                _TIFFfree(rbuff);
                              return (-1);
                              }
                             break;
                    case 3:
                    case 4:
                    case 5: if (rotateContigSamples32bits(rotation, spp, bps, width,
                       length, col, src, dst)){
                _TIFFfree(rbuff);
                              return (-1);
                              }
                             break;
                    default: TIFFError("rotateImage","Unsupported bit depth %d", bps);
               _TIFFfree(rbuff);
                             return (-1);
      }
    }
  }
              _TIFFfree(ibuff);
              *(ibuff_ptr) = rbuff;

              *img_width = length;
              *img_length = width;
              image->width = length;
              image->length = width;
              res_temp = image->xres;
              image->xres = image->yres;
              image->yres = res_temp;
              break;
    default:
              break;
    }

  return (0);
  }

static int
reverseSamples8bits (uint16 spp, uint16 bps, uint32 width,
                     uint8 *ibuff, uint8 *obuff){
  int ready_bits = 0;
  uint32 col;
  uint32 src_byte, src_bit;
  uint32 bit_offset = 0;
  uint8 match_bits = 0, mask_bits = 0;
  uint8 buff1 = 0, buff2 = 0;
  unsigned char *src;
  unsigned char *dst;
  tsample_t sample;

  if ((ibuff == NULL) || (obuff == NULL)){
    TIFFError("reverseSamples8bits","Invalid image or work buffer");
    return (1);
    }

  ready_bits = 0;
  mask_bits = (uint8)-1 >> ( 8 - bps);
  dst = obuff;
  for (col = width; col > 0; col--){

    bit_offset = (col - 1) * bps * spp;
    for (sample = 0; sample < spp; sample++){
      if (sample == 0){
        src_byte = bit_offset / 8;
        src_bit = bit_offset % 8;
        }
      else{
        src_byte = (bit_offset + (sample * bps)) / 8;
        src_bit = (bit_offset + (sample * bps)) % 8;
        }

      src = ibuff + src_byte;
      match_bits = mask_bits << (8 - src_bit - bps);
      buff1 = ((*src) & match_bits) << (src_bit);

      if (ready_bits < 8)
        buff2 = (buff2 | (buff1 >> ready_bits));
      else{
        *dst++ = buff2;
        buff2 = buff1;
        ready_bits -= 8;
        }
      ready_bits += bps;
      }
    }
  if (ready_bits > 0){
    buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));
    *dst++ = buff1;
    }

  return (0);
  }


static int
reverseSamples16bits (uint16 spp, uint16 bps, uint32 width,
                      uint8 *ibuff, uint8 *obuff){
  int ready_bits = 0;
  uint32 col;
  uint32 src_byte = 0, high_bit = 0;
  uint32 bit_offset = 0;
  uint16 match_bits = 0, mask_bits = 0;
  uint16 buff1 = 0, buff2 = 0;
  uint8 bytebuff = 0;
  unsigned char *src;
  unsigned char *dst;
  tsample_t sample;

  if ((ibuff == NULL) || (obuff == NULL)){
    TIFFError("reverseSample16bits","Invalid image or work buffer");
    return (1);
    }

  ready_bits = 0;
  mask_bits = (uint16)-1 >> (16 - bps);
  dst = obuff;
  for (col = width; col > 0; col--){

    bit_offset = (col - 1) * bps * spp;
    for (sample = 0; sample < spp; sample++){
      if (sample == 0){
        src_byte = bit_offset / 8;
        high_bit = bit_offset % 8;
        }
      else{
        src_byte = (bit_offset + (sample * bps)) / 8;
        high_bit = (bit_offset + (sample * bps)) % 8;
        }

      src = ibuff + src_byte;
      match_bits = mask_bits << (16 - high_bit - bps);
      if (little_endian)
        buff1 = (src[0] << 8) | src[1];
      else
        buff1 = (src[1] << 8) | src[0];
      buff1 = (buff1 & match_bits) << (high_bit);

      if (ready_bits < 8){
        bytebuff = 0;
        buff2 = (buff2 | (buff1 >> ready_bits));
        }
      else{
        bytebuff = (buff2 >> 8);
        *dst++ = bytebuff;
        ready_bits -= 8;

        buff2 = ((buff2 << 8) | (buff1 >> ready_bits));
        }
      ready_bits += bps;
      }
    }

  if (ready_bits > 0){
    bytebuff = (buff2 >> 8);
    *dst++ = bytebuff;
    }

  return (0);
  }

static int
reverseSamples24bits (uint16 spp, uint16 bps, uint32 width,
                      uint8 *ibuff, uint8 *obuff){
  int ready_bits = 0;
  uint32 col;
  uint32 src_byte = 0, high_bit = 0;
  uint32 bit_offset = 0;
  uint32 match_bits = 0, mask_bits = 0;
  uint32 buff1 = 0, buff2 = 0;
  uint8 bytebuff1 = 0, bytebuff2 = 0;
  unsigned char *src;
  unsigned char *dst;
  tsample_t sample;

  if ((ibuff == NULL) || (obuff == NULL)){
    TIFFError("reverseSamples24bits","Invalid image or work buffer");
    return (1);
    }

  ready_bits = 0;
  mask_bits = (uint32)-1 >> (32 - bps);
  dst = obuff;
  for (col = width; col > 0; col--){

    bit_offset = (col - 1) * bps * spp;
    for (sample = 0; sample < spp; sample++){
      if (sample == 0){
        src_byte = bit_offset / 8;
        high_bit = bit_offset % 8;
        }
      else{
        src_byte = (bit_offset + (sample * bps)) / 8;
        high_bit = (bit_offset + (sample * bps)) % 8;
        }

      src = ibuff + src_byte;
      match_bits = mask_bits << (32 - high_bit - bps);
      if (little_endian)
 buff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];
      else
 buff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];
      buff1 = (buff1 & match_bits) << (high_bit);

      if (ready_bits < 16){
        bytebuff1 = bytebuff2 = 0;
        buff2 = (buff2 | (buff1 >> ready_bits));
        }
      else{
        bytebuff1 = (buff2 >> 24);
        *dst++ = bytebuff1;
        bytebuff2 = (buff2 >> 16);
        *dst++ = bytebuff2;
        ready_bits -= 16;


        buff2 = ((buff2 << 16) | (buff1 >> ready_bits));
        }
      ready_bits += bps;
      }
    }


  while (ready_bits > 0){
    bytebuff1 = (buff2 >> 24);
    *dst++ = bytebuff1;

    buff2 = (buff2 << 8);
    bytebuff2 = bytebuff1;
    ready_bits -= 8;
    }

  return (0);
  }


static int
reverseSamples32bits (uint16 spp, uint16 bps, uint32 width,
                      uint8 *ibuff, uint8 *obuff){
  int ready_bits = 0 ;

  uint32 bit_offset;
  uint32 src_byte = 0, high_bit = 0;
  uint32 col;
  uint32 longbuff1 = 0, longbuff2 = 0;
  uint64 mask_bits = 0, match_bits = 0;
  uint64 buff1 = 0, buff2 = 0, buff3 = 0;
  uint8 bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;
  unsigned char *src;
  unsigned char *dst;
  tsample_t sample;

  if ((ibuff == NULL) || (obuff == NULL)){
    TIFFError("reverseSamples32bits","Invalid image or work buffer");
    return (1);
    }

  ready_bits = 0;
  mask_bits = (uint64)-1 >> (64 - bps);
  dst = obuff;
# 8895 "originals/113a.c"
  for (col = width; col > 0; col--){

    bit_offset = (col - 1) * bps * spp;
    for (sample = 0; sample < spp; sample++){
      if (sample == 0){
        src_byte = bit_offset / 8;
        high_bit = bit_offset % 8;
        }
      else{
        src_byte = (bit_offset + (sample * bps)) / 8;
        high_bit = (bit_offset + (sample * bps)) % 8;
        }

      src = ibuff + src_byte;
      match_bits = mask_bits << (64 - high_bit - bps);
      if (little_endian){
 longbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];
        longbuff2 = longbuff1;
        }
      else{
 longbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];
        longbuff2 = longbuff1;
 }
      buff3 = ((uint64)longbuff1 << 32) | longbuff2;
      buff1 = (buff3 & match_bits) << (high_bit);

      if (ready_bits < 32){
        bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;
        buff2 = (buff2 | (buff1 >> ready_bits));
        }
      else{
        bytebuff1 = (buff2 >> 56);
        *dst++ = bytebuff1;
        bytebuff2 = (buff2 >> 48);
        *dst++ = bytebuff2;
        bytebuff3 = (buff2 >> 40);
        *dst++ = bytebuff3;
        bytebuff4 = (buff2 >> 32);
        *dst++ = bytebuff4;
        ready_bits -= 32;


        buff2 = ((buff2 << 32) | (buff1 >> ready_bits));
        }
      ready_bits += bps;
      }
    }
  while (ready_bits > 0){
    bytebuff1 = (buff2 >> 56);
    *dst++ = bytebuff1;
    buff2 = (buff2 << 8);
    ready_bits -= 8;
    }

  return (0);
  }

static int
reverseSamplesBytes (uint16 spp, uint16 bps, uint32 width,
                     uint8 *src, uint8 *dst){
  int i;
  uint32 col, bytes_per_pixel, col_offset;
  uint8 bytebuff1;
  unsigned char swapbuff[32];

  if ((src == NULL) || (dst == NULL)){
    TIFFError("reverseSamplesBytes","Invalid input or output buffer");
    return (1);
    }

  bytes_per_pixel = ((bps * spp) + 7) / 8;
  if( bytes_per_pixel > sizeof(swapbuff) ){
    TIFFError("reverseSamplesBytes","bytes_per_pixel too large");
    return (1);
  }
  switch (bps / 8){
     case 8:
     case 4:
     case 3:
     case 2: for (col = 0; col < (width / 2); col++){
        col_offset = col * bytes_per_pixel;
        _TIFFmemcpy (swapbuff, src + col_offset, bytes_per_pixel);
        _TIFFmemcpy (src + col_offset, dst - col_offset - bytes_per_pixel, bytes_per_pixel);
        _TIFFmemcpy (dst - col_offset - bytes_per_pixel, swapbuff, bytes_per_pixel);
               }
      break;
     case 1:
             for (col = 0; col < (width / 2); col++){
        for (i = 0; i < spp; i++){
    bytebuff1 = *src;
    *src++ = *(dst - spp + i);
                  *(dst - spp + i) = bytebuff1;
    }
  dst -= spp;
                }
      break;
     default: TIFFError("reverseSamplesBytes","Unsupported bit depth %d", bps);
       return (1);
     }
  return (0);
  }



static int
mirrorImage(uint16 spp, uint16 bps, uint16 mirror, uint32 width, uint32 length, unsigned char *ibuff){
  int shift_width;
  uint32 bytes_per_pixel, bytes_per_sample;
  uint32 row, rowsize, row_offset;
  unsigned char *line_buff = NULL;
  unsigned char *src;
  unsigned char *dst;

  src = ibuff;
  rowsize = ((width * bps * spp) + 7) / 8;
  switch (mirror){
    case MIRROR_BOTH:
    case MIRROR_VERT:
             line_buff = (unsigned char *)_TIFFmalloc(rowsize);
             if (line_buff == NULL){
        TIFFError ("mirrorImage", "Unable to allocate mirror line buffer of %1u bytes", rowsize);
               return (-1);
               }

             dst = ibuff + (rowsize * (length - 1));
             for (row = 0; row < length / 2; row++){
       _TIFFmemcpy(line_buff, src, rowsize);
       _TIFFmemcpy(src, dst, rowsize);
       _TIFFmemcpy(dst, line_buff, rowsize);
               src += (rowsize);
               dst -= (rowsize);
               }
             if (line_buff)
               _TIFFfree(line_buff);
             if (mirror == MIRROR_VERT)
               break;
    case MIRROR_HORIZ :
              if ((bps % 8) == 0){
                for (row = 0; row < length; row++){
    row_offset = row * rowsize;
                  src = ibuff + row_offset;
                  dst = ibuff + row_offset + rowsize;
                  if (reverseSamplesBytes(spp, bps, width, src, dst)){
      return (-1);
                    }
    }
  }
       else{
                if (!(line_buff = (unsigned char *)_TIFFmalloc(rowsize + 1))){
                  TIFFError("mirrorImage", "Unable to allocate mirror line buffer");
                  return (-1);
                  }
                bytes_per_sample = (bps + 7) / 8;
                bytes_per_pixel = ((bps * spp) + 7) / 8;
                if (bytes_per_pixel < (bytes_per_sample + 1))
                  shift_width = bytes_per_pixel;
                else
                  shift_width = bytes_per_sample + 1;

                for (row = 0; row < length; row++){
    row_offset = row * rowsize;
                  src = ibuff + row_offset;
                  _TIFFmemset (line_buff, '\0', rowsize);
                  switch (shift_width){
                    case 1: if (reverseSamples16bits(spp, bps, width, src, line_buff)){
                _TIFFfree(line_buff);
                              return (-1);
                              }
                             _TIFFmemcpy (src, line_buff, rowsize);
                             break;
                    case 2: if (reverseSamples24bits(spp, bps, width, src, line_buff)){
                _TIFFfree(line_buff);
                              return (-1);
                              }
                             _TIFFmemcpy (src, line_buff, rowsize);
                             break;
                    case 3:
                    case 4:
                    case 5: if (reverseSamples32bits(spp, bps, width, src, line_buff)){
                _TIFFfree(line_buff);
                              return (-1);
                              }
                             _TIFFmemcpy (src, line_buff, rowsize);
                             break;
                    default: TIFFError("mirrorImage","Unsupported bit depth %d", bps);
               _TIFFfree(line_buff);
                             return (-1);
                    }
    }
                if (line_buff)
                  _TIFFfree(line_buff);
  }
             break;

    default: TIFFError ("mirrorImage", "Invalid mirror axis %d", mirror);
             return (-1);
             break;
    }

  return (0);
  }


static int
invertImage(uint16 photometric, uint16 spp, uint16 bps, uint32 width, uint32 length, unsigned char *work_buff){
  uint32 row, col;
  unsigned char bytebuff1, bytebuff2, bytebuff3, bytebuff4;
  unsigned char *src;
  uint16 *src_uint16;
  uint32 *src_uint32;

  if (spp != 1){
    TIFFError("invertImage", "Image inversion not supported for more than one sample per pixel");
    return (-1);
    }

  if (photometric != PHOTOMETRIC_MINISWHITE && photometric != PHOTOMETRIC_MINISBLACK){
    TIFFError("invertImage", "Only black and white and grayscale images can be inverted");
    return (-1);
    }

  src = work_buff;
  if (src == NULL){
    TIFFError ("invertImage", "Invalid crop buffer passed to invertImage");
    return (-1);
    }

  switch (bps){
    case 32: src_uint32 = (uint32 *)src;
             for (row = 0; row < length; row++)
               for (col = 0; col < width; col++){
   *src_uint32 = (uint32)0xFFFFFFFF - *src_uint32;
                  src_uint32++;
                 }
            break;
    case 16: src_uint16 = (uint16 *)src;
             for (row = 0; row < length; row++)
               for (col = 0; col < width; col++){
   *src_uint16 = (uint16)0xFFFF - *src_uint16;
                  src_uint16++;
                 }
            break;
    case 8: for (row = 0; row < length; row++)
              for (col = 0; col < width; col++){
  *src = (uint8)255 - *src;
                 src++;
                }
            break;
    case 4: for (row = 0; row < length; row++)
              for (col = 0; col < width; col++){
  bytebuff1 = 16 - (uint8)(*src & 240 >> 4);
  bytebuff2 = 16 - (*src & 15);
  *src = bytebuff1 << 4 & bytebuff2;
                src++;
                }
            break;
    case 2: for (row = 0; row < length; row++)
              for (col = 0; col < width; col++){
  bytebuff1 = 4 - (uint8)(*src & 192 >> 6);
  bytebuff2 = 4 - (uint8)(*src & 48 >> 4);
  bytebuff3 = 4 - (uint8)(*src & 12 >> 2);
  bytebuff4 = 4 - (uint8)(*src & 3);
  *src = (bytebuff1 << 6) || (bytebuff2 << 4) || (bytebuff3 << 2) || bytebuff4;
                src++;
                }
            break;
    case 1: for (row = 0; row < length; row++)
              for (col = 0; col < width; col += 8 /(spp * bps)){
                *src = ~(*src);
                src++;
                }
            break;
    default: TIFFError("invertImage", "Unsupported bit depth %d", bps);
      return (-1);
    }

  return (0);
  }

#include "tiffiop.h"

#define IGNORE 0
#define FAILED_FII ((uint32) -1)

#ifdef HAVE_IEEEFP
#define TIFFCvtIEEEFloatToNative(tif,n,fp) 
#define TIFFCvtIEEEDoubleToNative(tif,n,dp) 
#else
extern void TIFFCvtIEEEFloatToNative(TIFF*, uint32, float*);
extern void TIFFCvtIEEEDoubleToNative(TIFF*, uint32, double*);
#endif

enum TIFFReadDirEntryErr{
 TIFFReadDirEntryErrOk = 0,
 TIFFReadDirEntryErrCount = 1,
 TIFFReadDirEntryErrType = 2,
 TIFFReadDirEntryErrIo = 3,
 TIFFReadDirEntryErrRange = 4,
 TIFFReadDirEntryErrPsdif = 5,
 TIFFReadDirEntryErrSizesan = 6,
 TIFFReadDirEntryErrAlloc = 7,
};
